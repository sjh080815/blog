<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huck</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://39.97.232.17/"/>
  <updated>2020-03-12T12:13:00.390Z</updated>
  <id>http://39.97.232.17/</id>
  
  <author>
    <name>Huck</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis/创建redis集群</title>
    <link href="http://39.97.232.17/2020/03/12/redis/%E5%88%9B%E5%BB%BAredis%E9%9B%86%E7%BE%A4/"/>
    <id>http://39.97.232.17/2020/03/12/redis/%E5%88%9B%E5%BB%BAredis%E9%9B%86%E7%BE%A4/</id>
    <published>2020-03-12T11:11:56.850Z</published>
    <updated>2020-03-12T12:13:00.390Z</updated>
    
    <content type="html"><![CDATA[<p>redis集群和哨兵的用途相似，但是集群更适合用于生产。其具有以下优势：</p><ol><li>数据自动切片分布到节点上</li><li>节点挂掉的适合，其他节点可以顶上</li></ol><p>节点内服务器分别负责处理不同hash端的数据。利用CRC16的算法，对key进行分发处理。</p><p>当创建完成一个集群后，集群负责处理的hash段的顶是固定的，所以当增加节点的时候，这个节点的hash段将分别从各个节点的底部去一部分，凑成一个新节点。</p><p>目前的集群架构，最低需要3Master和3Slave。这几个节点互相为主从结构，将数据分布储存，并进行主从复制。</p><h1 id="Redis节点一致性"><a href="#Redis节点一致性" class="headerlink" title="Redis节点一致性"></a>Redis节点一致性</h1><p>节点间的复制原理如下：</p><ol><li>cli向一台主机发送写指令</li><li>主机向cli发送一个状态</li><li>主机将请求分发给其他主机</li></ol><p>这是一种异步写操作，其他主机复制时候，可能会发生数据不一致的情况。</p><h1 id="redis集群搭建"><a href="#redis集群搭建" class="headerlink" title="redis集群搭建"></a>redis集群搭建</h1><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>下载redis的源码文件，进行编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># wget http://download.redis.io/releases/redis-3.2.9.tar.gz</span></span><br><span class="line">bash<span class="comment"># tar -zxvf redis-3.2.9.tar.gz</span></span><br><span class="line">bash<span class="comment"># cd redis-3.2.9</span></span><br></pre></td></tr></table></figure><p>redis编译需要gcc和tcl的支持，手动安装一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># yum install gcc tcl</span></span><br></pre></td></tr></table></figure><p>编译安装一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># make &amp;&amp; make PREFIX=/usr/local/redis</span></span><br></pre></td></tr></table></figure><p>通常情况下，redis集群由多台服务器组成，每台服务器上也会跑多个数据节点。在这里，一个进程被看作了一个节点，只要节点监听的端口不发生冲突，那么就可以一台主机开多个节点了。</p><p>创建redis的配置文件（多节点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># mkdir &#123;7000..7005&#125;</span></span><br><span class="line">bash<span class="comment"># touch &#123;7000..7005&#125;/redis.conf</span></span><br></pre></td></tr></table></figure><p>这里只是创建了一个空白的redis配置文件，当然，咱们也可以使用软件自带的配置文件进行修改。</p><p>在配置文件中，打开集群配置，修改pid、aof和rdb的位置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">port 7000</span><br><span class="line"># 后台启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line">#集群节点配置文件</span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"># 集群连接超时时间</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"># 进程pid的文件位置</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-7000.pid</span><br><span class="line"># 开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"># aof文件路径</span><br><span class="line">appendfilename &quot;appendonly-7005.aof&quot;</span><br><span class="line"># rdb文件路径</span><br><span class="line">dbfilename dump-7000.rdb</span><br></pre></td></tr></table></figure><p>启动集群内节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># bin/redis-server cluster/7000/redis.conf</span></span><br></pre></td></tr></table></figure><p>使用官方的redis-trib.rb工具生成集群，但是这个工具使用了ruby的环境，我们先配置好ruby的环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># yum install ruby rubygems -y</span></span><br><span class="line">bash<span class="comment"># gem install redis</span></span><br></pre></td></tr></table></figure><p>创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span></span><br></pre></td></tr></table></figure><p>自动创建集群。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>使用redis-cli进行节点验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> a 5</span><br><span class="line">-&gt; Redirected to slot [15495] located at 127.0.0.1:7005</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7005&gt; get a</span><br><span class="line"><span class="string">"5"</span></span><br><span class="line">127.0.0.1:7005&gt; <span class="built_in">set</span> szac sa </span><br><span class="line">-&gt; Redirected to slot [8894] located at 127.0.0.1:7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get szac</span><br><span class="line"><span class="string">"sa"</span></span><br></pre></td></tr></table></figure><p>可以看出来，发生了节点漂移，就是集群成功了。</p><h1 id="模拟宕机检验"><a href="#模拟宕机检验" class="headerlink" title="模拟宕机检验"></a>模拟宕机检验</h1><p>我们先看一下redis的健康监测工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># ./redis-trib.rb check 127.0.0.1:7001</span></span><br></pre></td></tr></table></figure><p>redis-trib.rb不仅提供了集群组件方案，也提供了集群的健康监测方案。这一段就是进行了健康监测。</p><p>这一段命令会返回当前的所有在线的节点，我们先挂掉7000节点看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># ./redis-trib.rb check 127.0.0.1:7001</span></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span><br><span class="line">M: 315e2abf264b2437b0ba859483adcc7fd81d2655 127.0.0.1:7001</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 68ba481a27f25ef8eecc15bfd6e32fbd579fda79 127.0.0.1:7003</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">M: 3ac136984eb0d24dfcb057da36f39a0fa71752a0 127.0.0.1:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 5b5385b9885c1116dd956dc393909d9eabcbfe10 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 315e2abf264b2437b0ba859483adcc7fd81d2655</span><br><span class="line">S: 63f3ee573957e786cf1395cb21086ed445afd5ca 127.0.0.1:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3ac136984eb0d24dfcb057da36f39a0fa71752a0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>这里的集群自动割除了那个挂掉的节点，当前的服务器工作仍然正常，这就保证了数据的高可用。</p><p>重新启动刚才挂掉的服务，在进行监测，会发现集群内又出现了这个节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis集群和哨兵的用途相似，但是集群更适合用于生产。其具有以下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据自动切片分布到节点上&lt;/li&gt;
&lt;li&gt;节点挂掉的适合，其他节点可以顶上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;节点内服务器分别负责处理不同hash端的数据。利用CRC16的算法，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>gzip模块</title>
    <link href="http://39.97.232.17/2020/03/09/Nginx%E8%B0%83%E4%BC%98/gzip%E6%A8%A1%E5%9D%97/"/>
    <id>http://39.97.232.17/2020/03/09/Nginx%E8%B0%83%E4%BC%98/gzip%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-09T15:21:07.000Z</published>
    <updated>2020-03-09T15:39:25.683Z</updated>
    
    <content type="html"><![CDATA[<p>Gzip是nginx内置的一个压缩模块，对发送的数据进行压缩，在质量和速度上取得一个折中，提高服务的性能。</p><p>Gzip通常被写到server块中，下边看一看这个模块的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gzip off;</span><br><span class="line"></span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">gzip_comp_level 1;</span><br><span class="line"></span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png application&#x2F;vnd.ms-fontobject font&#x2F;ttf font&#x2F;opentype font&#x2F;x-woff image&#x2F;svg+xml;</span><br><span class="line"></span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line">gzip_buffers 32 4k;</span><br><span class="line"></span><br><span class="line">gzip_http_version 1.0;</span><br></pre></td></tr></table></figure><p>这是gzip常用的几个配置，从上往下看：</p><p>gzip on|off： 这是控制gzip开关的字段。相当于开关。</p><p>gzip_min_length： 设置了压缩的最小文件长度。通常来说，小文件是不需要进行压缩的，压缩后反而会降低原本的质量。所以需要设置一个最小压缩下限，防止小文件按被压缩。</p><p>gzip_comp_level：压缩等级。这个压缩等级需要根据实际的需求改。不推荐一次设置的很高，这样反而会降低网站的质量。</p><p>gzip_type：压缩格式。一般的说，所有静态资源都是浏览器向nginx服务器请求获得的，当服务器接收到不同的文件请求时，需要进行不同的压缩方案。这里就设置了需要压缩的格式。</p><p>gzip_vary： 在header中加入vary字段。</p><p>gzip_disable： 设置不进行压缩的请求头。有浏览器和gzip时不兼容的，这里通常会禁用ie的gzip。</p><p>gzip_buffer：压缩缓冲区。作用就是对压缩的文件进行缓冲加载。</p><p>gzip_http_version： 压缩的http请求版本。有1.0和1.1.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gzip是nginx内置的一个压缩模块，对发送的数据进行压缩，在质量和速度上取得一个折中，提高服务的性能。&lt;/p&gt;
&lt;p&gt;Gzip通常被写到server块中，下边看一看这个模块的写法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://39.97.232.17/categories/Nginx/"/>
    
    
      <category term="http服务器" scheme="http://39.97.232.17/tags/http%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器性能指标</title>
    <link href="http://39.97.232.17/2020/03/09/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <id>http://39.97.232.17/2020/03/09/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</id>
    <published>2020-03-09T07:39:25.000Z</published>
    <updated>2020-03-09T08:36:13.153Z</updated>
    
    <content type="html"><![CDATA[<p>Linux服务器和大部分PC机一样，都有CPU、内存、硬盘和主板等部件构成。服务器特有阵列卡，是为冗余储存设计的，制约服务器性能的参数有一下几条：</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>CPU是服务器的核心。目前服务器CPU常用英特尔至强系列，英特尔E7系列服务器CPU是当前比较高性能的CPU了。服务器一般情况下是使用的双CPU，有的甚至使用多个CPU。一般的来说，服务器有一个CPU就可以完成运算了，但是为了追求算力的最大化和服务的稳定性，通常会使用到双CPU或者多CPU。主板搭载多CPU时，这些CPU会进行并行运算，从而获得最大的算力。</p><p>我们可以在/dev/cpu查看cpu硬件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># ll /dev/cpu</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root      80 Mar  3 18:09 0</span><br><span class="line">drwxr-xr-x 2 root root      80 Mar  3 18:09 1</span><br><span class="line">crw------- 1 root root 10, 184 Mar  3 18:09 microcode</span><br></pre></td></tr></table></figure><p>这里展现了cpu的硬件。</p><p>我们可以通过查看/proc/cpuinfo文件来查询CPU的具体情况。</p><p>下边介绍一下CPU的技术指标：</p><h2 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h2><p>CPU频率就是通常意义上的数据处理频率。一般情况下，CPU频率越高，CPU的运算能力越强。但是通常会因为温度问题制约CPU的性能。所以，CPU的降温非常重要。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一般情况下，CPU时会设计有三级缓存的，这三级缓存主要时用做内存和CPU之间的数据通信缓冲的。</p><p>那么，从这一点就不难得出，当CPU的频率较高时，一定有较大的缓存，一般的说，CPU频率越高，内存也会给的越大。</p><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>虚拟化技术时服务器上最常用到的。目前各大厂商的云计算服务器都推崇虚拟化。虚拟化的依赖就是CPU的虚拟化技术。一般来说，英特尔至强系列的CPU都会支持intel-VT技术，保障虚拟化的实施。</p><h2 id="物理核和逻辑核"><a href="#物理核和逻辑核" class="headerlink" title="物理核和逻辑核"></a>物理核和逻辑核</h2><p>咱们经常会听到有人说几何几线程。这里的核就是物理核，线程就是逻辑核。通常来说，逻辑核是物理核的二倍。就这一点我们就可以得出一个结论，逻辑核是由物理核模拟出来的。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>内存也是服务器的一个重要组成部分。根据冯诺依曼的结构理论来说，内存的大小和质量也直接的影响了设备对数据的处理能力。</p><p>我们的PC机，目前用的内存是常规没有ECC的内存，价格较高，频率也比较高，一般不会低于2000MHz。服务器用的内存条是ECC内存条，相比于PC机用的内存，更廉价，频率更低。单从稳定性和容量上，服务器就不可能选用普通内存。</p><p>下边是内存的几个技术指标：</p><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>就是我们通常理解的容量。服务器的内存容量都是非常大的，一台主机可能都会由及时G的样子。</p><h2 id="频率-1"><a href="#频率-1" class="headerlink" title="频率"></a>频率</h2><p>内存的频率和CPU的有些类似，我就不单说了。</p><blockquote><p><strong>插入知识：swap</strong><br>swap叫内存交换区。这个交换区有点像一个缓冲区。当内存的性能不能匹配CPU的处理速度的时候，会使用swap来进行缓冲。<br>swap是基于硬盘的，所以数据的存储效率可能会低于内存。</p></blockquote><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>通常的服务器集群中，都不会直接把数据存放到业务服务器上，都是将数据存放在数据存储集群的。数据存储集群也依赖于硬盘，硬盘的效率对服务器的快速性也由很大的影响。</p><h2 id="硬盘容量"><a href="#硬盘容量" class="headerlink" title="硬盘容量"></a>硬盘容量</h2><p>即为硬盘的大小，没有什么需要说的。</p><h2 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h2><p>和CPU缓存的原理一样，不多赘述。</p><h2 id="SAS和SATA"><a href="#SAS和SATA" class="headerlink" title="SAS和SATA"></a>SAS和SATA</h2><p>这是两种硬盘的接口方式。SAS硬盘常用于服务器上，SATA硬盘常用于PC机上，就稳定性而言，SAS略胜一筹。</p><h2 id="SSD和HDD"><a href="#SSD和HDD" class="headerlink" title="SSD和HDD"></a>SSD和HDD</h2><p>SSD被称为固态硬盘，HDD被称为机械硬盘。固态硬盘很少有用在服务器上，原因是企业级的SSD成本非常高，而且当数据丢失的时候不易于恢复，基本丢数据就是永久性的。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>数据吞吐量，即I/O。一般意义上I/O越大，效果就越好，服务器的处理速度就越快。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>网络是体统服务的媒介，网络的速度直接影响客户的体验。目四七年机房采用的网络模式基本都是专线接入，超大带宽。下边是几个网络的技术参数：</p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>网络都会有延迟，这个延迟的时间取决于客户端和服务器之间网关的响应时间。如果是跨运营商访问，那么访问的延迟一般都会比较大。</p><h2 id="吞吐量-1"><a href="#吞吐量-1" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>就是广泛意义上的网速。</p><h2 id="百千万兆"><a href="#百千万兆" class="headerlink" title="百千万兆"></a>百千万兆</h2><p>这个表示的不是网络带宽，指的是网络的模式。这个单位是Mbps。网络模式要和网卡，网线，交换机设备都匹配才能体现出最佳性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux服务器和大部分PC机一样，都有CPU、内存、硬盘和主板等部件构成。服务器特有阵列卡，是为冗余储存设计的，制约服务器性能的参数有一下几条：&lt;/p&gt;
&lt;h1 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;
      
    
    </summary>
    
    
      <category term="业务理论" scheme="http://39.97.232.17/categories/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="业务理论" scheme="http://39.97.232.17/tags/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>镜像</title>
    <link href="http://39.97.232.17/2020/03/08/docker/%E9%95%9C%E5%83%8F/"/>
    <id>http://39.97.232.17/2020/03/08/docker/%E9%95%9C%E5%83%8F/</id>
    <published>2020-03-08T12:19:13.893Z</published>
    <updated>2020-03-08T11:39:35.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>镜像是被封装好的服务，镜像可以随时调用，方便进行部署。镜像可以是docker hub上的，也可以是自己封装的。</p></blockquote><p>咱们看一下系统镜像的组成</p><p><img src="img/docker-filesystems-multilayer.png" alt=""></p><p>可以认为镜像都是多镜像叠加起来的。</p><p>咱们要部署环境，第一件事就是查找相关镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search image_name:tag</span><br></pre></td></tr></table></figure><p>系统会返回相关的镜像信息，咱们以centos为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server etc]# docker search centos</span><br><span class="line">INDEX       NAME                                         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io&#x2F;centos                             The official build of CentOS.                   5703      [OK]</span><br><span class="line">docker.io   docker.io&#x2F;ansible&#x2F;centos7-ansible            Ansible on Centos7                              126                  [OK]</span><br></pre></td></tr></table></figure><p>看一下返回的东西。INDEX是镜像库，NAME是镜像名，DESCRIPTION是镜像简介，OFFICIAL表示是否官方镜像，AUTOMATED表示自动部署。</p><p>咱们再看看搜索命令，image_name后有tag，一般情况下，tag表示的是镜像的版本，但是也有其他的用途。</p><p>获取到镜像信息了，咱们可以拉取镜像了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull image_name:tag</span><br></pre></td></tr></table></figure><p>咱们再这里发现，拉取镜像的时候有多个拉取进度条，这就可以说明，镜像是多个镜像叠加成的。</p><p>拉取镜像和查询镜像的时候，可以不要tag。如果不要tag的话，那就是拉取最新的镜像，及默认latest。</p><p>拉取镜像到本地后，咱们可以查看以下本地的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/centos    latest              0f3e07c0138f        2 months ago        220 MB</span><br></pre></td></tr></table></figure><p>看看这个列表。</p><p>REPOSITORY表示镜像来源，TAG表示镜像的标签。</p><p>IMAGE ID这个参数很重要。每个镜像都会分配一个image id，且唯一。这个image id是拉取镜像的时候系统给分配的。所以再docker hub上是没有分配image id的。</p><p>CREATED表示拉取镜像的时间，是拉取镜像到现在的时长。SIZE表示镜像的大小。</p><p><strong>咱们看看这个SIZE。一个完整的centos大概需要6G左右，但是这里只有200M左右，且能完成基本的服务功能。这就体现出了容器化相对于虚拟化的优越性了。</strong></p><p>运行以下镜像吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd 0f3e07c0138f</span><br></pre></td></tr></table></figure><p>镜像这样就运行起来了，咱们看一下状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d24f69f87efb        0f3e07c0138f        <span class="string">"/bin/bash"</span>         4 seconds ago       Up 2 seconds</span><br></pre></td></tr></table></figure><p>运行成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;镜像是被封装好的服务，镜像可以随时调用，方便进行部署。镜像可以是docker hub上的，也可以是自己封装的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱们看一下系统镜像的组成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/docker-filesy
      
    
    </summary>
    
    
      <category term="docker" scheme="http://39.97.232.17/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://39.97.232.17/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://39.97.232.17/2020/03/08/docker/%E7%BD%91%E7%BB%9C/"/>
    <id>http://39.97.232.17/2020/03/08/docker/%E7%BD%91%E7%BB%9C/</id>
    <published>2020-03-08T12:19:13.888Z</published>
    <updated>2020-03-08T11:40:50.642Z</updated>
    
    <content type="html"><![CDATA[<p>docker网络默认时使用NAT模式的，结构图如下</p><p><img src="img/1529328359399810.png" alt=""></p><p>这张图上有两种模式。第一个容器是host模式，该容器的的IP和主机是相同的，和主机共享网络。第二个是bridge模式。</p><p>主要说一下bridge模式。</p><p>在docker内部，软件会生成一个虚拟网关，形成一个虚拟的网络。容器分配的IP是这个虚拟网关分配的。外网无法访问，除非在创建容器的时候创建端口映射。</p><h1 id="查看docker网络"><a href="#查看docker网络" class="headerlink" title="查看docker网络"></a>查看docker网络</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">194c884755b2        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">ee717ffaa64f        host                host                <span class="built_in">local</span></span><br><span class="line">f39060423673        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>上边是docker的三种网络模式。</p><p>在主机上执行ip add命令可以发现一条信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:98:a4:a1:70 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1&#x2F;16 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:98ff:fea4:a170&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这是docker创建的虚拟网卡，这里以虚拟网卡为网关。</p><h2 id="bridge通信原理"><a href="#bridge通信原理" class="headerlink" title="bridge通信原理"></a>bridge通信原理</h2><p>容器将数据发送到虚拟网卡上，然后通过虚拟网卡发送出去。外网访问也是同理。</p><h1 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h1><p>因为有虚拟网络存在，所以外网因为有内网隔离无法访问到容器。我们需要添加端口映射。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 主机端口:容器端口 image_id</span><br></pre></td></tr></table></figure><p>这样的话外网就可以访问到相应的端口了。</p><p>也可所以使用-P参数，就是随机分配端口。</p><h1 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h1><p>创建容器时添加–link参数，在新容器的hosts文件添加原容器的解析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;docker网络默认时使用NAT模式的，结构图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/1529328359399810.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这张图上有两种模式。第一个容器是host模式，该容器的的IP和主机是相同的，和主机共享网络。第二个是bri
      
    
    </summary>
    
    
      <category term="docker" scheme="http://39.97.232.17/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://39.97.232.17/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据卷</title>
    <link href="http://39.97.232.17/2020/03/08/docker/%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>http://39.97.232.17/2020/03/08/docker/%E6%95%B0%E6%8D%AE%E5%8D%B7/</id>
    <published>2020-03-08T12:19:13.878Z</published>
    <updated>2020-03-08T11:40:16.117Z</updated>
    
    <content type="html"><![CDATA[<p>数据卷可将主机和容器之间做文件上的连接，更便于容器中的文件管理。</p><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>添加数据卷。在创建容器的时候添加-v参数，即可添加数据卷。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v 本地目录:容器目录 image_id</span><br></pre></td></tr></table></figure><p>这里可以不写容器目录，如果不写的话是给容器加载了数据卷，但是不挂载。如果加容器目录则加载到容器内。</p><p>目录可以改成文件，则是文件挂载。</p><h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><p>数据卷容器时一个容器，就是把容器作为数据卷挂载到新容器。</p><p>创建数据卷容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><p>挂载数据卷容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from dbdata --name db1 ubuntu</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据卷可将主机和容器之间做文件上的连接，更便于容器中的文件管理。&lt;/p&gt;
&lt;h1 id=&quot;数据卷&quot;&gt;&lt;a href=&quot;#数据卷&quot; class=&quot;headerlink&quot; title=&quot;数据卷&quot;&gt;&lt;/a&gt;数据卷&lt;/h1&gt;&lt;p&gt;添加数据卷。在创建容器的时候添加-v参数，即可添加数
      
    
    </summary>
    
    
      <category term="docker" scheme="http://39.97.232.17/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://39.97.232.17/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="http://39.97.232.17/2020/03/08/docker/%E5%AE%B9%E5%99%A8/"/>
    <id>http://39.97.232.17/2020/03/08/docker/%E5%AE%B9%E5%99%A8/</id>
    <published>2020-03-08T12:19:13.868Z</published>
    <updated>2020-03-08T11:39:53.104Z</updated>
    
    <content type="html"><![CDATA[<p>容器就是镜像跑起来之后的东西。容器之间可以互相访问，但是和实环境隔离。</p><p>咱们看一下运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d24f69f87efb        0f3e07c0138f        <span class="string">"/bin/bash"</span>         6 hours ago         Up 6 seconds                            epic_bose</span><br></pre></td></tr></table></figure><p>看一下上边的参数。</p><p>CONTAINER ID 容器的ID号。</p><p>IMAGE 容器的来源镜像ID。</p><p>COMMAND 容器运行时候的命令。</p><p>CREATED 创建时间。</p><p>PORTS 端口映射。</p><p>NAMES 容器名。</p><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><p>容器由镜像创建来，且一直保存。则容器往往会有运行和停止两个状态。</p><p>启动容器<code>docker start CONTAINER ID</code></p><p>停止容器<code>docker stop CONTAINER ID</code></p><p>有时候咱们启动容器了，但是发现查看容器的时候还是有问题，不能启动。一般情况下，容器不会没有原因的无法启动，肯定是出问题了，那么就看看容器的日志。</p><figure class="highlight docker"><figcaption><span>logs CONTAINER ID```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">分析一下日志信息，按照信息报的错误修改配置。</span><br><span class="line"></span><br><span class="line">容器也不是永远都有用的，所以有时候我们会删除有些容器。</span><br><span class="line"></span><br><span class="line">```docker rm CONTAINER ID</span><br></pre></td></tr></table></figure><p><strong>注意：运行中的容器不能删除，所以一般情况需要停止容器才能删除。如果要强制删除的话直接加参数-f就好了。</strong></p><h1 id="文件交互"><a href="#文件交互" class="headerlink" title="文件交互"></a>文件交互</h1><p>有时候需要将物理机上的文件拷贝到容器中，有时候需要将容器中的文件拷贝到本地。这个直接使用docker的拷贝功能就好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp file CONTAINER_ID:file <span class="comment">#本地复制到容器</span></span><br><span class="line">docker cp CONTAINER_ID:file file <span class="comment">#容器复制到本地</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器就是镜像跑起来之后的东西。容器之间可以互相访问，但是和实环境隔离。&lt;/p&gt;
&lt;p&gt;咱们看一下运行的容器：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="docker" scheme="http://39.97.232.17/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://39.97.232.17/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>docker的安装和配置</title>
    <link href="http://39.97.232.17/2020/03/08/docker/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://39.97.232.17/2020/03/08/docker/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-08T12:19:13.863Z</published>
    <updated>2020-03-08T11:39:11.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker是目前容器化的常用软件，它可以隔离真是主机环境，且上线环境部署容易，容灾性高。</p></blockquote><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>docker可以通过yum进行安装，安装方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装后，咱们最好更改一下docker的加速源，修改<code>/etc/docker/daemon.json</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启以下docker服务就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Docker是目前容器化的常用软件，它可以隔离真是主机环境，且上线环境部署容易，容灾性高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境
      
    
    </summary>
    
    
      <category term="docker" scheme="http://39.97.232.17/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://39.97.232.17/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>模块</title>
    <link href="http://39.97.232.17/2020/03/08/ansible/%E6%A8%A1%E5%9D%97/"/>
    <id>http://39.97.232.17/2020/03/08/ansible/%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-08T12:19:13.840Z</published>
    <updated>2020-03-08T11:35:59.368Z</updated>
    
    <content type="html"><![CDATA[<p>ansible 和 saltstack 相似，都是调用相关模块实现功能的，有一些模块是我们很常用的。</p><p>这里调用模块的方法和 saltstack 不同，需要使用 -m 参数进行调用。</p><h1 id="ping-模块"><a href="#ping-模块" class="headerlink" title="ping 模块"></a>ping 模块</h1><p>和广义上的 ping 意义相似，都是进行主机连通性测试的，检查群内主机是否在线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s1 log]# ansible all -m ping </span><br><span class="line">192.168.89.130 | SUCCESS &#x3D;&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.168.89.129 | SUCCESS &#x3D;&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现success就说明主机是在线的。</p><h1 id="command-模块"><a href="#command-模块" class="headerlink" title="command 模块"></a>command 模块</h1><p>自动化操作基本都是基于ssh远程操作的shell指令的，我们会经常使用shell语句进行系统的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s1 log]# ansible test -m command -a &#39;ls -al &#x2F;root&#39;</span><br><span class="line">192.168.89.130 | CHANGED | rc&#x3D;0 &gt;&gt;</span><br><span class="line">总用量 80</span><br><span class="line">dr-xr-x---.  5 root root  4096 1月  27 18:55 .</span><br><span class="line">dr-xr-xr-x. 17 root root   244 1月  27 18:49 ..</span><br><span class="line">-rw-------.  1 root root  1253 1月  27 16:07 anaconda-ks.cfg</span><br><span class="line">...</span><br><span class="line">-rw-r--r--.  1 root root   129 12月 29 2013 .tcshrc</span><br><span class="line"></span><br><span class="line">192.168.89.129 | CHANGED | rc&#x3D;0 &gt;&gt;</span><br><span class="line">总用量 68</span><br><span class="line">dr-xr-x---.  7 root root  4096 1月  27 20:00 .</span><br><span class="line">dr-xr-xr-x. 17 root root   244 1月  27 18:49 ..</span><br><span class="line">-rw-------.  1 root root  1253 1月  27 16:07 anaconda-ks.cfg</span><br><span class="line">...</span><br><span class="line">-rw-------   1 root root  1261 1月  27 20:00 .viminfo</span><br></pre></td></tr></table></figure><p>调用command模块后，使用-a参数传入要运行的shell语句。</p><p>有时候因为我们没有root权限，或者有些文件不能用root进行操作，那么我们会用到其他账户，使用 -u 参数有指定账户。</p><p>command模块的几个功能：</p><ol><li>removes：存在条件判断，当文件存在时运行后边的命令。</li><li>creates：不存在条件判断，当文件不存在的时候执行后边的命令。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s1 ~]# ansible all -a &#39;creates&#x3D;&#x2F;root&#x2F;setup.log cat &#x2F;root&#x2F;setup.log&#39;</span><br><span class="line">192.168.89.129 | SUCCESS | rc&#x3D;0 &gt;&gt;</span><br><span class="line">skipped, since &#x2F;root&#x2F;setup.log exists</span><br><span class="line"></span><br><span class="line">192.168.89.130 | SUCCESS | rc&#x3D;0 &gt;&gt;</span><br><span class="line">skipped, since &#x2F;root&#x2F;setup.log exists</span><br></pre></td></tr></table></figure><p>从以上文本可以看出，存在就不执行。</p><h2 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h2><p>这是标准的shell模块，和command相似，但是shell对于linux更专业，所以执行远程命令更推荐使用shell模块。</p><p>command模块不支持管道符，但是shell模块可以使用。</p><h1 id="Script-模块"><a href="#Script-模块" class="headerlink" title="Script 模块"></a>Script 模块</h1><p>一般情况下运行脚本需要将脚本文件分发到各主机上分别进行运行，这样很不方便，在ansible中我们使用了script模块，只需要在master主机上编辑脚本就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash# ansible all -m script -a &#39;&#x2F;root&#x2F;test.sh&#39;</span><br></pre></td></tr></table></figure><p>这样就分别在主机上执行了test.sh脚本，输出格式有普通输出和格式化输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;stdout&quot;: &quot;k8s1\r\n&quot;, </span><br><span class="line">&quot;stdout_lines&quot;: [</span><br><span class="line">    &quot;k8s1&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="copy-模块"><a href="#copy-模块" class="headerlink" title="copy 模块"></a>copy 模块</h1><p>就是复制模块，需要进行目标文件和目的的指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m copy -a &#39;src&#x3D;&#x2F;root&#x2F;test.sh dest&#x3D;&#x2F;tmp owner&#x3D;root group&#x3D;root mode&#x3D;0755&#39;</span><br></pre></td></tr></table></figure><p>这样就把文件以复制的方式分发给了主机。前提：master上存在这个文件。指定为src，目的指定为dest。</p><h1 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h1><p>yum模块是只针对于Centos的安装模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m yum -a &#39;name&#x3D;vim state&#x3D;latest&#39;</span><br></pre></td></tr></table></figure><p>上边这一段命令就给主机安装了vim编辑器。</p><h1 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a>service模块</h1><p>服务器的主要功能就是服务，服务器系统主要任务就是提供服务。我们经常会对集群内服务进行操作，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m service -a &#39;name&#x3D;nginx state&#x3D;started&#39;</span><br></pre></td></tr></table></figure><p>这段命令启动了nginx。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ansible 和 saltstack 相似，都是调用相关模块实现功能的，有一些模块是我们很常用的。&lt;/p&gt;
&lt;p&gt;这里调用模块的方法和 saltstack 不同，需要使用 -m 参数进行调用。&lt;/p&gt;
&lt;h1 id=&quot;ping-模块&quot;&gt;&lt;a href=&quot;#ping-模块&quot;
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://39.97.232.17/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://39.97.232.17/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>主机管理</title>
    <link href="http://39.97.232.17/2020/03/08/ansible/%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86/"/>
    <id>http://39.97.232.17/2020/03/08/ansible/%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86/</id>
    <published>2020-03-08T12:19:13.835Z</published>
    <updated>2020-03-08T11:36:22.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h1><p>在大型集群里，机器会分为多个可用域，每个可用域做的业务也不相同，执行的命令和在集群中承担的角色也不同，那就需要进行分组管理。</p><h2 id="创建分组："><a href="#创建分组：" class="headerlink" title="创建分组："></a>创建分组：</h2><p>在/etc/ansible/hosts文件下创建之际和组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[group]</span><br><span class="line">host</span><br></pre></td></tr></table></figure><p>这样就创建了一个管理组。</p><p>需要注意，ansible是基于ssh的集群管理工具，默认的链接端口是22，如果主机的ssh端口被修改过，则在声明hosts的时候著名ssh的端口。</p><p>有时候服务器的使用账户并非root，那就需要进行指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[group]</span><br><span class="line">host ansible_connection&#x3D;connect_method ansible_ssh_user&#x3D;user</span><br></pre></td></tr></table></figure><p>这样来指定ssh连接方式和连接的用户名。</p><h2 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h2><p>有时候需要给服务器增加一个变量或者标志，那么就在<br>hosts文件上添加变量即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[group]</span><br><span class="line">host var&#x3D;value</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分组管理&quot;&gt;&lt;a href=&quot;#分组管理&quot; class=&quot;headerlink&quot; title=&quot;分组管理&quot;&gt;&lt;/a&gt;分组管理&lt;/h1&gt;&lt;p&gt;在大型集群里，机器会分为多个可用域，每个可用域做的业务也不相同，执行的命令和在集群中承担的角色也不同，那就需要进行分组管理。
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://39.97.232.17/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://39.97.232.17/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>playbook</title>
    <link href="http://39.97.232.17/2020/03/08/ansible/playbook/"/>
    <id>http://39.97.232.17/2020/03/08/ansible/playbook/</id>
    <published>2020-03-08T12:19:13.830Z</published>
    <updated>2020-03-08T11:35:29.863Z</updated>
    
    <content type="html"><![CDATA[<p>playbook就是和saltstack类似的yaml部署描述文件。一个playbooks内包含一个或多个play，下面对play进行一下解析：</p><p>下边是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: webservers</span><br><span class="line">  vars:</span><br><span class="line">    http_port: 80</span><br><span class="line">    max_clients: 200</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: ensure apache is at the latest version</span><br><span class="line">    yum: pkg&#x3D;httpd state&#x3D;latest</span><br><span class="line">  - name: write the apache config file</span><br><span class="line">    template: src&#x3D;&#x2F;srv&#x2F;httpd.j2 dest&#x3D;&#x2F;etc&#x2F;httpd.conf</span><br><span class="line">    notify:</span><br><span class="line">    - restart apache</span><br><span class="line">  - name: ensure apache is running</span><br><span class="line">    service: name&#x3D;httpd state&#x3D;started</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service: name&#x3D;httpd state&#x3D;restarted</span><br></pre></td></tr></table></figure><h1 id="指定机器"><a href="#指定机器" class="headerlink" title="指定机器"></a>指定机器</h1><p>在yaml的前半段是对机器、用户和组的配置。</p><ul><li>hosts：指定执行的机器或者组</li><li>remote_user：运行的用户</li></ul><p>** 这里可以添加sudo: yes语句，表示使用sudo执行操作**</p><ul><li>vars：创建变量表</li></ul><h1 id="tasks-表"><a href="#tasks-表" class="headerlink" title="tasks 表"></a>tasks 表</h1><p>tasks表就是任务表，每个数据元素就是一个任务。</p><p>这是一个简单的nginx自动构建playbook。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- hosts: test</span><br><span class="line">  vars:</span><br><span class="line">    httpport: 80</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install nginx</span><br><span class="line">      yum: pkg&#x3D;nginx state&#x3D;latest</span><br><span class="line">    - name: start nginx</span><br><span class="line">      service: name&#x3D;nginx state&#x3D;started</span><br></pre></td></tr></table></figure><p>这个文件包含了两个task。</p><p>第一个是安装nginx，直接调用yum，用pkg key指定安装nginx，用state指定安装的版本。</p><p>第二个是服务状态控制。安装完成后nginx的状态是关闭的，需要进行手动启动。这里使用了service模块进行了自动启动。在name中指定服务名，在state中指定服务状态。</p><p>这里要注意，service指定的state必须是reload，started或者stopped，其他状态都是无效的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;playbook就是和saltstack类似的yaml部署描述文件。一个playbooks内包含一个或多个play，下面对play进行一下解析：&lt;/p&gt;
&lt;p&gt;下边是一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://39.97.232.17/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://39.97.232.17/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ansible安装</title>
    <link href="http://39.97.232.17/2020/03/08/ansible/ansible%E5%AE%89%E8%A3%85/"/>
    <id>http://39.97.232.17/2020/03/08/ansible/ansible%E5%AE%89%E8%A3%85/</id>
    <published>2020-03-08T12:19:13.826Z</published>
    <updated>2020-03-08T11:27:47.276Z</updated>
    
    <content type="html"><![CDATA[<p>ansible是一个基于SSH协议的自动化运维工具，通常使用的时候需要给其他主机配置免密登录，且只需要安装控制端。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在控制端安装依赖及主程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">yum install ansible</span><br></pre></td></tr></table></figure><p>也可以使用pip安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install ansible</span><br></pre></td></tr></table></figure><p>安装好后进行主机配置和远程配置。</p><p>在控制端配置/etc/ansible/hosts文件，在这个文件里可以使用ip，也可以使用hostname（那就需要使用hosts文件对主机进行解析或者DNS能进行解析）。</p><p><img src="img/1.png" alt="1.png"></p><p>生成SSH公钥，将公钥信息下发给被控制主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>可以看到，生成的rsa公钥被存放在~/.ssh/id_rsa.pub中，那么久需要将这个文件下发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.89.129</span><br></pre></td></tr></table></figure><p>这样就配置好了SSH免密登录。</p><p>对配置好的集群进行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">bash#</span><span class="bash"> ansible all -m ping</span></span><br><span class="line"></span><br><span class="line">192.168.89.130 | SUCCESS =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line"></span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    "changed": false,</span><br><span class="line"></span><br><span class="line">    "ping": "pong"</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">192.168.89.129 | SUCCESS =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line"></span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    "changed": false,</span><br><span class="line"></span><br><span class="line">    "ping": "pong"</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条命令和saltstack的test.ping的用途相同，就是尝试进行服务器间的通信测试。这里的两条success表示测试正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ansible是一个基于SSH协议的自动化运维工具，通常使用的时候需要给其他主机配置免密登录，且只需要安装控制端。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;在控制端安
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://39.97.232.17/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://39.97.232.17/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>灰度发布</title>
    <link href="http://39.97.232.17/2020/03/08/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    <id>http://39.97.232.17/2020/03/08/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</id>
    <published>2020-03-08T12:19:13.816Z</published>
    <updated>2020-03-08T15:24:50.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>灰度发布就是在黑和白之间发布网站。假设有一个黑区和白区。黑区使用旧版本的产品，白区发布新版本产品，然后对白区进行产品调研。如果白区没有什么意见，则可白区向黑区扩散。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>beta和正式版。对特定用户推送beta版本产品，进行使用状况调研，然后根据调研逐渐将beta转化为正式版。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;灰度发布就是在黑和白之间发布网站。假设有一个黑区和白区。黑区使用旧版本的产品，白区发布新版本产品，然后对白区进行产品调研。如果白区没有什么意
      
    
    </summary>
    
    
      <category term="业务理论" scheme="http://39.97.232.17/categories/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="业务理论" scheme="http://39.97.232.17/tags/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/虚拟化及磁盘</title>
    <link href="http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E7%A3%81%E7%9B%98/"/>
    <id>http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E7%A3%81%E7%9B%98/</id>
    <published>2020-03-08T12:19:13.599Z</published>
    <updated>2020-01-13T11:22:49.369Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机，我们常叫做实例。一个实例就含一个最基本的服务器的最小系统，包括虚拟硬件系统和软件系统。</p><p>通常生产环节的服务器不适用GUI界面，但是再做KVM的时候，需要GUI界面做辅助管理，所以再安装KVM之前务必先安装桌面。</p><p><strong>KVM最终生成的配置文件是xml文件</strong></p><p>创建虚拟机时，使用命令<code>virt-install</code>创建KVM虚拟机。</p><p>常用参数：</p><ul><li>name：虚拟机名</li><li>vCPUs：虚拟CPU核心数</li><li>ram：虚拟内存大小</li><li>os-type：系统类型</li><li>cdrom：CD挂载的镜像文件</li><li>file：虚拟机硬盘文件</li><li>file-size：虚拟硬盘大小</li></ul><h1 id="虚拟硬盘"><a href="#虚拟硬盘" class="headerlink" title="虚拟硬盘"></a>虚拟硬盘</h1><p>通常情况，任何电脑想运行起来都得有硬盘做数据存储支持，所以，咱们先创建虚拟硬盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create xxx.qcow2 -f qcow2 size</span><br></pre></td></tr></table></figure><p>上述代码创建了一个qcow2格式的虚拟硬盘。</p><p>虚拟磁盘大概有两种类型，一个是IDE，一个是Virtio。根据读写数据测试，Virtio是性能最好的方案。</p><p>虚拟磁盘的格式也有很多种，用的最多的是qcow2格式的硬盘文件。</p><p>QEMU支持常见使用的raw和qcow2格式。</p><h1 id="硬盘虚拟化的主要操作"><a href="#硬盘虚拟化的主要操作" class="headerlink" title="硬盘虚拟化的主要操作"></a>硬盘虚拟化的主要操作</h1><h2 id="硬盘创建"><a href="#硬盘创建" class="headerlink" title="硬盘创建"></a>硬盘创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create test 50G</span><br></pre></td></tr></table></figure><p>创建一个50G的硬盘，但是没有写是什么格式。要实际使用必须给一个指定的硬盘格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create test.qcow2 -f qcow2 50G</span><br></pre></td></tr></table></figure><p>上边就是指定生成一个qcow2格式的硬盘。注意钱两段语句test有无后缀。</p><p>这里不写绝对地址，那么就再当前目录生成文件。</p><p>可以通过<code>qemu-img info test.qcow2</code>查看生成硬盘的信息。</p><h2 id="硬盘格式转换"><a href="#硬盘格式转换" class="headerlink" title="硬盘格式转换"></a>硬盘格式转换</h2><p>平时硬盘也就一两种格式常用，但是有时候也会使用其他格式，那么就需要进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img convert -p -f raw -O qcow2 test test1.qcow2</span><br></pre></td></tr></table></figure><p>#快照</p><p>快照就是系统在某一个瞬间被“抓拍”到的状态，这个状态可以随时进行恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot test.qcow2 -c s1</span><br></pre></td></tr></table></figure><p>以上代码创建了一个名为s1的快照，我们可以查看一下快照列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot test.qcow2 -l</span><br></pre></td></tr></table></figure><p>镜像是用来给特殊情况下给服务器做还原用的，所以必然就会用到还原，使用a参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot test.qcow2 -a s1</span><br></pre></td></tr></table></figure><h1 id="后备镜像"><a href="#后备镜像" class="headerlink" title="后备镜像"></a>后备镜像</h1><p>后备镜像就是常说的公有镜像，一个后备镜像可以做多个虚拟机的母盘。</p><p>后备（backend）使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 -b backend img_name</span><br></pre></td></tr></table></figure><p>使用后备磁盘创建一个虚拟硬盘。</p><h1 id="虚拟硬盘属性定义"><a href="#虚拟硬盘属性定义" class="headerlink" title="虚拟硬盘属性定义"></a>虚拟硬盘属性定义</h1><p>最常用的硬盘指标是容量，虚拟主机经常会出现硬盘不足，那么我们就需要手动再给加大硬盘了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img resize test1.qcow2 +2G</span><br></pre></td></tr></table></figure><p>这里是给元硬盘的基础加2G，当然也可以写成需要改到的大小。</p><h1 id="裸设备"><a href="#裸设备" class="headerlink" title="裸设备"></a>裸设备</h1><p>为让虚拟机获取极致的算力和性能，可以直接挂在裸硬盘到虚拟机。也可以使用lvm，但是lvm需要关闭cache，防止数据丢失。</p><h1 id="常用虚拟硬盘格式对比"><a href="#常用虚拟硬盘格式对比" class="headerlink" title="常用虚拟硬盘格式对比"></a>常用虚拟硬盘格式对比</h1><p>RAW：整体性能较高</p><p>qcow2：常见的虚拟硬盘格式，适合高消耗计算</p><p>lvm：适合高IO的计算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虚拟机，我们常叫做实例。一个实例就含一个最基本的服务器的最小系统，包括虚拟硬件系统和软件系统。&lt;/p&gt;
&lt;p&gt;通常生产环节的服务器不适用GUI界面，但是再做KVM的时候，需要GUI界面做辅助管理，所以再安装KVM之前务必先安装桌面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KVM最终
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/网络虚拟化</title>
    <link href="http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2020-03-08T12:19:13.591Z</published>
    <updated>2020-01-13T11:22:49.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟化分类"><a href="#虚拟化分类" class="headerlink" title="虚拟化分类"></a>虚拟化分类</h1><p>虚拟化可分为半虚拟化和全虚拟化。半虚拟化和全虚拟化的本质区别在于虚拟化层。</p><h1 id="半虚拟化网络（Virtio驱动）"><a href="#半虚拟化网络（Virtio驱动）" class="headerlink" title="半虚拟化网络（Virtio驱动）"></a>半虚拟化网络（Virtio驱动）</h1><p>半虚拟化主机需要对客户机操作系统进行一定的修改才能使用。半虚拟化宿主机和虚拟机都需要安装Virtio的虚拟工具。</p><h2 id="半虚拟化安装过程"><a href="#半虚拟化安装过程" class="headerlink" title="半虚拟化安装过程"></a>半虚拟化安装过程</h2><p>目前主流操作系统都默认带有Virtio的网络驱动，只需要再内核中看看是否支持。</p><p>在启动虚拟机的时候加入参数virtio-net-oci，指定网卡if=virtio（网卡类型）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟化分类&quot;&gt;&lt;a href=&quot;#虚拟化分类&quot; class=&quot;headerlink&quot; title=&quot;虚拟化分类&quot;&gt;&lt;/a&gt;虚拟化分类&lt;/h1&gt;&lt;p&gt;虚拟化可分为半虚拟化和全虚拟化。半虚拟化和全虚拟化的本质区别在于虚拟化层。&lt;/p&gt;
&lt;h1 id=&quot;半虚拟化网络（V
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/KVM概念</title>
    <link href="http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/KVM%E6%A6%82%E5%BF%B5/"/>
    <id>http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/KVM%E6%A6%82%E5%BF%B5/</id>
    <published>2020-03-08T12:19:13.587Z</published>
    <updated>2020-01-13T11:22:49.347Z</updated>
    
    <content type="html"><![CDATA[<p>目前各大云计算厂商都在使用虚拟化云服务，大部分以VMware、Xen和KVM（Openstack）等架构，KVM是使用最广的虚拟化方案。</p><p>虚拟化是将空闲的硬件资源分配到虚拟计算机中，使服务器的性能能达到最好，发挥到极致。</p><p>KVM是内核加强虚拟机，从他的名称可以看出这是个基于内核的功能。</p><p>KVM是虚拟机软件，那么运行这个软件则要有CPU虚拟化选项打开，否则CPU无法进行虚拟化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前各大云计算厂商都在使用虚拟化云服务，大部分以VMware、Xen和KVM（Openstack）等架构，KVM是使用最广的虚拟化方案。&lt;/p&gt;
&lt;p&gt;虚拟化是将空闲的硬件资源分配到虚拟计算机中，使服务器的性能能达到最好，发挥到极致。&lt;/p&gt;
&lt;p&gt;KVM是内核加强虚拟机，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/CPU虚拟及内存虚拟</title>
    <link href="http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/CPU%E8%99%9A%E6%8B%9F%E5%8F%8A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F/"/>
    <id>http://39.97.232.17/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/CPU%E8%99%9A%E6%8B%9F%E5%8F%8A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F/</id>
    <published>2020-03-08T12:19:13.583Z</published>
    <updated>2020-01-13T11:22:49.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件虚拟化（CPU和内存）"><a href="#硬件虚拟化（CPU和内存）" class="headerlink" title="硬件虚拟化（CPU和内存）"></a>硬件虚拟化（CPU和内存）</h1><h2 id="常用CPU架构"><a href="#常用CPU架构" class="headerlink" title="常用CPU架构"></a>常用CPU架构</h2><h3 id="SMP技术"><a href="#SMP技术" class="headerlink" title="SMP技术"></a>SMP技术</h3><p>这种架构CPU共同访问所有内存，速率比较低，且效率也低。</p><h3 id="NUMA技术"><a href="#NUMA技术" class="headerlink" title="NUMA技术"></a>NUMA技术</h3><p>这是最常见的虚拟化技术，CPU直接通信自己所属的内存，直接调用，效率较高。</p><p><strong>这里需要用到numactl插件，需手动安装一下</strong></p><p>看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash$ numactl --hardware</span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7</span><br><span class="line">node 0 size: 7850 MB</span><br><span class="line">node 0 free: 4704 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0 </span><br><span class="line">  0:  10</span><br></pre></td></tr></table></figure><p>从以上代码得，这台电脑是单CPU，是多核的CPU。内存一共7850M，空余4704M。</p><p>查看NUMA使用的内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash# numasat -c qemu-kvm</span><br><span class="line">Per-node numastat info (in MBs):</span><br><span class="line">                Node 0 Total</span><br><span class="line">                ------ -----</span><br><span class="line">Numa_Hit         19365 19365</span><br><span class="line">Numa_Miss            0     0</span><br><span class="line">Numa_Foreign         0     0</span><br><span class="line">Interleave_Hit     175   175</span><br><span class="line">Local_Node       19365 19365</span><br><span class="line">Other_Node           0     0</span><br><span class="line">Local_Node       19365 19365</span><br><span class="line">Other_Node           0     0</span><br></pre></td></tr></table></figure><p>可以看到内存的占用状况。</p><h1 id="KSM技术："><a href="#KSM技术：" class="headerlink" title="KSM技术："></a>KSM技术：</h1><p>虚拟主句和宿主主机内存合并。</p><h2 id="内存气球技术"><a href="#内存气球技术" class="headerlink" title="内存气球技术"></a>内存气球技术</h2><p>需要virt balloon插件调节内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;硬件虚拟化（CPU和内存）&quot;&gt;&lt;a href=&quot;#硬件虚拟化（CPU和内存）&quot; class=&quot;headerlink&quot; title=&quot;硬件虚拟化（CPU和内存）&quot;&gt;&lt;/a&gt;硬件虚拟化（CPU和内存）&lt;/h1&gt;&lt;h2 id=&quot;常用CPU架构&quot;&gt;&lt;a href=&quot;#常用
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试常见问题/uniq和sort</title>
    <link href="http://39.97.232.17/2020/03/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/uniq%E5%92%8Csort/"/>
    <id>http://39.97.232.17/2020/03/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/uniq%E5%92%8Csort/</id>
    <published>2020-03-08T12:19:13.566Z</published>
    <updated>2020-02-27T06:30:16.811Z</updated>
    
    <content type="html"><![CDATA[<p>sort和uniq是两个查看文件时候经常会用到的筛选工具。</p><p>sort：升序输出，将输入的文本以升序的方式进行输出。</p><p>uniq：降重输出。把输入文本里的重复数据剔除然后输出。</p><h1 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h1><p>查看nginx的PV地址：</p><p>nginx一般会配置access.log日志文件，查询这个日志文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># cat access.log</span></span><br><span class="line"></span><br><span class="line">111.20.59.9 - - [25/Feb/2020:17:29:04 +0800] <span class="string">"GET /zabbix/favicon.ico HTTP/1.1"</span> 200 32988 <span class="string">"http://39.97.232.17/zabbix/zabbix.php?action=dashboard.view&amp;ddreset=1"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.1</span></span><br><span class="line"><span class="string">112</span></span><br></pre></td></tr></table></figure><p>分析日志结构，发现第一列是用户的RealIP，也就是这里的PV，后边是http请求头的一些参数。</p><p>按要求进行排序并降重：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># cat access.log | awk '&#123;print $1&#125;' | sort | uniq</span></span><br></pre></td></tr></table></figure><p>分析命令：第二段使用了awk进行了正则筛选，选中了第一列数据。将选中的数据进行升序和降重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sort和uniq是两个查看文件时候经常会用到的筛选工具。&lt;/p&gt;
&lt;p&gt;sort：升序输出，将输入的文本以升序的方式进行输出。&lt;/p&gt;
&lt;p&gt;uniq：降重输出。把输入文本里的重复数据剔除然后输出。&lt;/p&gt;
&lt;h1 id=&quot;面试常见问题&quot;&gt;&lt;a href=&quot;#面试常见问题
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试常见问题/rsync和scp</title>
    <link href="http://39.97.232.17/2020/03/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/rsync%E5%92%8Cscp/"/>
    <id>http://39.97.232.17/2020/03/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/rsync%E5%92%8Cscp/</id>
    <published>2020-03-08T12:19:13.562Z</published>
    <updated>2020-02-27T11:00:11.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rsync和scp"><a href="#rsync和scp" class="headerlink" title="rsync和scp"></a>rsync和scp</h1><p>rsync是一种常见的征粮备份工具，scp常被用做文件传输。</p><h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p>可以进行软硬连接的拷贝。这个文件传输的方式是同步。</p><p>同步的过程中，如果从机的相关目录存在，那reync会惊醒数据比较，对数据不同的进行更新。</p><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>scp不支持连接的传输。传输方式是复制。</p><p>复制的过程中，如果从机存在相关的目录，会直接进行覆盖复制。</p><p><strong>从上边综合考虑，rsync更适合于文件同步，scp更适合于文件传输。</strong></p><h1 id="大集群管理方案"><a href="#大集群管理方案" class="headerlink" title="大集群管理方案"></a>大集群管理方案</h1><ol><li>使用跳板机（这里可以使用jumpserver，开源），对集群进行统一管理</li><li>使用自动化工具（ansible）</li><li>运维安全：一般关闭selinux和firewalld，使用物理防火墙</li></ol><h1 id="Toncat和Resin"><a href="#Toncat和Resin" class="headerlink" title="Toncat和Resin"></a>Toncat和Resin</h1><p>Tomcat是很常用的一种java web服务器，用户多，适合于中小型企业。兼容性好，文献多。</p><p>Resin性能更好，常被大型企业采用。</p><h1 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h1><p>解析服从三个优先级：</p><ol><li>查看自身的hosts文件</li><li>在本地设置的DNS服务器解析</li><li>在跟服务器中解析（先查一级根服务器，再查二级根服务器）</li></ol><h1 id="keepalived原理"><a href="#keepalived原理" class="headerlink" title="keepalived原理"></a>keepalived原理</h1><p>再虚拟路由中，Master一直发送VRRP，BACKUP不会抢占VIP，当Master宕机时，BACKUP直接按照优先级抢占VIP。</p><h1 id="LVS原理"><a href="#LVS原理" class="headerlink" title="LVS原理"></a>LVS原理</h1><ol><li><p>NAT模式<br>均衡器收到请求，将请求的目的IP转向RS。回传报文的适合，将RS的IP换成均衡器的IP。<br>优点：只需要均衡器有IP。<br>缺点：服务器过多时效率变低。</p></li><li><p>路由模式（DR）<br>LVS做了调度器，请求发送到LVS上，LVS调度转发到RS上，RS直接返回数据，不经过LVS。<br>LVS的网卡和RS服务器的网卡需要再一个网段上。</p></li><li><p>隧道模式（TUN）<br>多地多中心方案的调度器。此时的VIP，DIP和RIP都是公网IP。客户向VIP发送请求，调度器将请求转发给RS。<br>缺点：服务器局限部分linux系统</p></li></ol><h1 id="MySQL复制延迟问题"><a href="#MySQL复制延迟问题" class="headerlink" title="MySQL复制延迟问题"></a>MySQL复制延迟问题</h1><ol><li>主从硬件差异</li><li>主从线程不匹配</li><li>SQL赘余</li><li>网络延迟</li><li>主库压力大</li></ol><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈： 先入后出，只可末尾单端操作。</p><p>队列： 先入先出，单端入，单端出。</p><h1 id="ping原理"><a href="#ping原理" class="headerlink" title="ping原理"></a>ping原理</h1><p>用icmp协议探测远端请求是否可达。</p><h1 id="LNMP卡顿现象排查"><a href="#LNMP卡顿现象排查" class="headerlink" title="LNMP卡顿现象排查"></a>LNMP卡顿现象排查</h1><ol><li>检查服务器的硬件负载（方案：查看MySQL负载，如果MySQL也能正常，那就可以考虑提升设备性能）</li><li>检查服务器的网口负载（方案：使用CDN，加大宽带）</li><li>检查Nginx连接、进程数量（方案：修改Nginx配置，适配于本设备硬件）</li><li>查看php-fpm进程（方案：修改php.ini配置文件）</li><li>查看MySQL负载，查日志（方案：拆日志，加redis等缓存技术）</li></ol><h1 id="MySQL查询慢"><a href="#MySQL查询慢" class="headerlink" title="MySQL查询慢"></a>MySQL查询慢</h1><ol><li>没有索引</li><li>I/O小</li><li>内存不足</li><li>网速较慢（也有外网连接的mysql）</li><li>数据量过大</li><li>死锁</li><li>返回了不必要列</li><li>没优化好</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rsync和scp&quot;&gt;&lt;a href=&quot;#rsync和scp&quot; class=&quot;headerlink&quot; title=&quot;rsync和scp&quot;&gt;&lt;/a&gt;rsync和scp&lt;/h1&gt;&lt;p&gt;rsync是一种常见的征粮备份工具，scp常被用做文件传输。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>面试常见问题/LVS、Haproxy和Nginx用作proxy服务器</title>
    <link href="http://39.97.232.17/2020/03/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/LVS%E3%80%81Haproxy%E5%92%8CNginx%E7%94%A8%E4%BD%9Cproxy%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://39.97.232.17/2020/03/08/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/LVS%E3%80%81Haproxy%E5%92%8CNginx%E7%94%A8%E4%BD%9Cproxy%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-08T12:19:13.557Z</published>
    <updated>2020-02-21T06:21:32.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx服务器常被用做静态web服务器和反向代理服务器，这种代理在web环境中用的较多。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>工作在七层，对http协议做分流</li><li>对网络依赖较小</li><li>安装和配置简单</li><li>抗压</li><li>适合做web应用服务器</li><li>做中层反向代理服务器</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>仅支持http和https及邮箱协议</li><li>对于后端服务器稳定性要求较高。上传数据时如果后端服务器宕机，Nginx会直接切换后端服务器。</li></ol><h1 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h1><p>LVS时一种运行在四层协议上的调度器。</p><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ol><li>抗高压</li><li>配置简单</li><li>工作在四层，基本可以转发所有数据</li><li>工作更稳定</li><li>LVS只负责分发</li></ol><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ol><li>不支持正则，不能做web动静分离</li><li>网站系统过于庞大</li></ol><h1 id="Haproxy"><a href="#Haproxy" class="headerlink" title="Haproxy"></a>Haproxy</h1><p>这是一种工作在四/七层的代理软件。</p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ol><li>支持虚拟主机</li><li>可以保持session和cookie</li><li>速度更快</li><li>可对MySQL做读写负载均衡</li><li>策略更多</li></ol><h2 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h2><ol><li>不支持POP/SMTP协议</li><li>不支持SPDY协议</li><li>不支持HTTP cache</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;&lt;p&gt;Nginx服务器常被用做静态web服务器和反向代理服务器，这种代理在web环境中用的较多。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
