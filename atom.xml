<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huck</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.huckops.xyz/"/>
  <updated>2020-03-16T16:14:37.502Z</updated>
  <id>http://www.huckops.xyz/</id>
  
  <author>
    <name>Huck</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初始化容器</title>
    <link href="http://www.huckops.xyz/2020/03/16/kubernetes/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.huckops.xyz/2020/03/16/kubernetes/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8/</id>
    <published>2020-03-16T15:54:21.000Z</published>
    <updated>2020-03-16T16:14:37.502Z</updated>
    
    <content type="html"><![CDATA[<p>容器再生成的时候是什么都没有的，相当于一个空白的环境。通常情况下，容器内都是要运行相关的服务器的，需要对这个生产容器传递一些项目文件或者一些配置文件，这就需要引入一个中间过程，initContrainer。</p><p>这是初始化容器。初始化容器会在生成生产容器的时候，先构建一个过渡容器，在这个容器完成一些文件生成或者文件下载（比如git clone，或者wget）等命令，把数据存放到volume中，实现容器中共享。</p><p>下边是一个例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">make-index</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">buxybox</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">wget</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"-O"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"/dir/index.html"</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">"http://39.97.232.17/index.html"</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/dir</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol</span></span><br><span class="line">        <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">"128Mi"</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">"500m"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">vol</span></span><br><span class="line">      <span class="attr">emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>对这个yaml进行技术分析。</p><p>这里使用了初始化容器，使用的是busybox的环境。在busybox容器中下载了我的博客主页，放到了volume中。然后把数据卷再挂给生产容器。</p><p>这里没有给nginx容器添加service，所以就不能进行nodeport访问，这里就不多做赘述了。通过curl命令来请求nginx的pod，返回可以看出数据变了。</p><p>我们看一下构建过程。</p><p>获取nginx Pod的describe：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># kubectl describe pod nginx</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  23m   default-scheduler  Successfully assigned default/nginx to k8s2</span><br><span class="line">  Normal  Pulling    23m   kubelet, k8s2      Pulling image <span class="string">"busybox"</span></span><br><span class="line">  Normal  Pulled     23m   kubelet, k8s2      Successfully pulled image <span class="string">"busybox"</span></span><br><span class="line">  Normal  Created    23m   kubelet, k8s2      Created container make-index</span><br><span class="line">  Normal  Started    23m   kubelet, k8s2      Started container make-index</span><br><span class="line">  Normal  Pulling    23m   kubelet, k8s2      Pulling image <span class="string">"nginx"</span></span><br><span class="line">  Normal  Pulled     23m   kubelet, k8s2      Successfully pulled image <span class="string">"nginx"</span></span><br><span class="line">  Normal  Created    23m   kubelet, k8s2      Created container nginx</span><br><span class="line">  Normal  Started    23m   kubelet, k8s2      Started container nginx</span><br></pre></td></tr></table></figure><p>events罗列了构建这个pod的详细过程。可以看出来，先进性了拉取busybox容器，然后才创建的nginx容器。</p><p>这也就从时间上理清楚了业务的顺序：先生成（获取），再部署。</p><p>那么，当nginx容器建成了，busybox容器改何去何从，我们可以查一下docker的正在运行的容器：</p><p>再node上运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker ps -a</span></span><br><span class="line">0200b6db1930        busybox                <span class="string">"wget -O /dir/index.…"</span>   27 minutes ago      Exited (0) 27 minutes ago                         k8s_make-index_nginx_default_1476fcdd-2bb3-448e-a587-3861d731ddb7_0</span><br></pre></td></tr></table></figure><p>查到如上的一段记录。</p><p>很明显的我们可以看到，这条记录中有Exited（0），就是容器退出了。</p><p>再创建完成主容器后，初始化容器将不会被直接删除，但是会被以停止的状态放到服务器上。当主容器删除的时候，这个容器也会跟着一起删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器再生成的时候是什么都没有的，相当于一个空白的环境。通常情况下，容器内都是要运行相关的服务器的，需要对这个生产容器传递一些项目文件或者一些配置文件，这就需要引入一个中间过程，initContrainer。&lt;/p&gt;
&lt;p&gt;这是初始化容器。初始化容器会在生成生产容器的时候，先
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://www.huckops.xyz/categories/kubernetes/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Ingress</title>
    <link href="http://www.huckops.xyz/2020/03/16/kubernetes/Ingress/"/>
    <id>http://www.huckops.xyz/2020/03/16/kubernetes/Ingress/</id>
    <published>2020-03-16T10:14:26.000Z</published>
    <updated>2020-03-17T03:00:24.351Z</updated>
    
    <content type="html"><![CDATA[<p>在真实环境做生产环境的时候，我们常常会用到七层代理来解决以些像跨域代理这样的问题。在k8s中，容器只有一个ip，通常被绑定到service上，service上通常只有一个ip，不能进行http请求头转发。这时候就需要引入一个技术叫Ingress。</p><p>Ingress是用在k8s集群中非常常用的一种七层转发技术，向深处剖析，可以看到，Ingress其实就是Nginx进行了七层代理转发。我们来看看这个技术的架构。</p><p><img src="https://intranetproxy.alipay.com/skylark/lark/0/2020/png/199230/1582465418798-afdfa4c2-02a2-4c9a-bace-75f271052c5b.png" alt=""></p><p>这个架构里最主要的一部分就是Ingress Controller。从上图可以看出，controller在这里对客户的请求进行了转发，转发到了相应的Service上，Service再通过负载均衡转发到Pod上。构成一条完整的转发链。</p><h1 id="Ingress的简单环境配置"><a href="#Ingress的简单环境配置" class="headerlink" title="Ingress的简单环境配置"></a>Ingress的简单环境配置</h1><p>下来看一下这个架构的搭建：</p><h2 id="安装Ingress-Controller"><a href="#安装Ingress-Controller" class="headerlink" title="安装Ingress-Controller"></a>安装Ingress-Controller</h2><p>这里通常使用k8s自动部署。yaml脚本如下（官方提供的方案或多或少有一些问题，不建议使用）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-configuration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tcp-services</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">udp-services</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-clusterrole</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">services</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">events</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"extensions"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"networking.k8s.io"</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"extensions"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"networking.k8s.io"</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ingresses/status</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-role</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">pods</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">    <span class="attr">resourceNames:</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"ingress-controller-leader-nginx"</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">update</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">configmaps</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">endpoints</span></span><br><span class="line">    <span class="attr">verbs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-role-nisa-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-role</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-clusterrole-nisa-binding</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-clusterrole</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/name:</span> <span class="string">ingress-nginx</span></span><br><span class="line">        <span class="attr">app.kubernetes.io/part-of:</span> <span class="string">ingress-nginx</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">prometheus.io/port:</span> <span class="string">"10254"</span></span><br><span class="line">        <span class="attr">prometheus.io/scrape:</span> <span class="string">"true"</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">     </span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">300</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-ingress-controller</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">registry.aliyuncs.com/google_containers/nginx-ingress-controller:0.26.1</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/nginx-ingress-controller</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--configmap=$(POD_NAMESPACE)/nginx-configuration</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--tcp-services-configmap=$(POD_NAMESPACE)/tcp-services</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--udp-services-configmap=$(POD_NAMESPACE)/udp-services</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--publish-service=$(POD_NAMESPACE)/ingress-nginx</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--annotations-prefix=nginx.ingress.kubernetes.io</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">capabilities:</span></span><br><span class="line">              <span class="attr">drop:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">              <span class="attr">add:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">NET_BIND_SERVICE</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">33</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">              <span class="attr">valueFrom:</span></span><br><span class="line">                <span class="attr">fieldRef:</span></span><br><span class="line">                  <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">              <span class="attr">containerPort:</span> <span class="number">443</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">10254</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">readinessProbe:</span></span><br><span class="line">            <span class="attr">failureThreshold:</span> <span class="number">3</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/healthz</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">10254</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">            <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">            <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">10</span></span><br><span class="line">          <span class="attr">lifecycle:</span></span><br><span class="line">            <span class="attr">preStop:</span></span><br><span class="line">              <span class="attr">exec:</span></span><br><span class="line">                <span class="attr">command:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">/wait-shutdown</span></span><br></pre></td></tr></table></figure><p>写入yaml后，执行这个yaml：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f xxx.yaml</span><br></pre></td></tr></table></figure><p>查看是否运行成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># kubectl get pods --all-namespaces</span></span><br><span class="line">ingress-nginx   nginx-ingress-controller-56d57fb4c7-b9cv7   1/1     Running   1          74m</span><br></pre></td></tr></table></figure><p>可以看出来，Ingress-Controller是一个Pod，那么他既然是个Pod，就有可能些重建，那么IP就会发生变化。因此，我们可以对这个Pod创建一个Service，映射到外网。</p><p>对于常规情况，Ingress会指定一个default的backend。当backend生效的时候，Ingress收到404的请求会直接跳转到这个backend。</p><p>这里没有使用到default backend就不多赘述了。</p><h2 id="创建backend"><a href="#创建backend" class="headerlink" title="创建backend"></a>创建backend</h2><p>和创建普通的Pod和Service一样，按常规写法来写。</p><h2 id="创建Ingress策略"><a href="#创建Ingress策略" class="headerlink" title="创建Ingress策略"></a>创建Ingress策略</h2><p>我们知道，Ingress的作用目的是进行请求转发，那么转发肯定是要有策略的，比如请求的host等。</p><p>创建一个host规则。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">www.test.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/demo</span></span><br><span class="line">            <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">nginx</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>这里创建了URI为demo的转发策略，转发时候会连同URI一起转发。</p><p>从这里得出一个结论。我们可以以URL为转发条件，也可以直接以URI为转发条件。当我们需要绑定多个host的时候，我们只需要再rule里多写几条host就好了。</p><p>如果不适用域名解析，那就不需要写host那一条字段。</p><h1 id="Ingress安全性"><a href="#Ingress安全性" class="headerlink" title="Ingress安全性"></a>Ingress安全性</h1><p>再通常情况下，服务器都是会用到TLS安全的。那么Ingress的环境下，也需要使用TLS，我们通常建立secret。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># kubectl create secret tls ingress-tls --key tls.key  --cert tls.crt</span></span><br></pre></td></tr></table></figure><p>这样就创建了一个叫ingress-tls的secret。</p><p>再创建Ingress的时候创建一个tls规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tls:</span><br><span class="line">  - host: test.com</span><br><span class="line">    secretName: ingress-tls</span><br></pre></td></tr></table></figure><p>这个时候创建service的时候记得创建两个端口映射，一个是80，一个是443。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在真实环境做生产环境的时候，我们常常会用到七层代理来解决以些像跨域代理这样的问题。在k8s中，容器只有一个ip，通常被绑定到service上，service上通常只有一个ip，不能进行http请求头转发。这时候就需要引入一个技术叫Ingress。&lt;/p&gt;
&lt;p&gt;Ingres
      
    
    </summary>
    
    
      <category term="kubernetes" scheme="http://www.huckops.xyz/categories/kubernetes/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>发版业务</title>
    <link href="http://www.huckops.xyz/2020/03/13/jenkins/%E5%8F%91%E7%89%88%E4%B8%9A%E5%8A%A1/"/>
    <id>http://www.huckops.xyz/2020/03/13/jenkins/%E5%8F%91%E7%89%88%E4%B8%9A%E5%8A%A1/</id>
    <published>2020-03-13T11:27:07.000Z</published>
    <updated>2020-03-13T12:24:29.599Z</updated>
    
    <content type="html"><![CDATA[<p>在生产环境中，产品往往都会净多多次修改，迭代，测试。特别是在进行产品测试的时候还需要频繁的进行部署。部署的工作在职能划分上属于运维的工作范畴，那么，我们总不可能每天等着开发那边的源码过来部署吗？这里就会牵扯到一个发版流程问题。</p><p>通常的来说，产品发版一般会经历以下几步：</p><ol><li>产品确定需求</li><li>开发进行编码</li><li>测试进行测试</li><li>运维进行上线</li><li>渠道对接</li></ol><p>这里我们需要了解发版的2，3和4过程。</p><p>2是开发，通常开发环境是程序员的虚拟机环境。这个虚拟机环境，可能每个程序员的使用习惯不同，环境也不同，和生产、测试环境也不同。这里不会用到自动化构建。</p><p>3是测试。测试要进行测试的环境一般是专用的测试环境，这个环境非常接近于生产环境，开发把源码推送到Git或者SVN上进行项目托管，运维负责把开发推过来的产品部署出来，让测试人员进行测试。</p><p>通常的，开发会向我们频繁的推送版本。根据git的相关知识可以知道，git在上传新版本后，老版本会被一定的覆盖掉，相当于说，旧版本就不存在了。那么，我们发版的时候就需要进行正常发版和版本滚回。那么，我们就使用以下的方案进行解决：</p><p>我们通常需要在创建流水线的时候创建一个选项参数。这个选项参数在编写jenkins自动部署脚本的时候可以作为一个变量来使用。</p><p>创建一个tag的字符参数。</p><p>这里引入新发版jenkins需要做的几个重要过程。</p><ol><li>勾子程序获取更新</li><li>打tag，就是把上一版的程序进行备份</li><li>将新的版本放入环境</li></ol><p>同样，tag也可以在创建pipeline的时候以变量的方式使用。</p><p>由上的思路可以知道，编写脚本的时候，写两个函数，然后使用case的方式对创建的选项参数进行选择执行。先cp旧版产品文件到tag下，然后将新版的产品cp到环境下。rollback是恢复参数，思路是将备份目录中的版本放入环境目录。</p><p>运维上线大概就是使用灰度发布了。对指定的用户进行发布测试，如果产品的效果不好，可以按以上的方式进行部署的滚回。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在生产环境中，产品往往都会净多多次修改，迭代，测试。特别是在进行产品测试的时候还需要频繁的进行部署。部署的工作在职能划分上属于运维的工作范畴，那么，我们总不可能每天等着开发那边的源码过来部署吗？这里就会牵扯到一个发版流程问题。&lt;/p&gt;
&lt;p&gt;通常的来说，产品发版一般会经历以
      
    
    </summary>
    
    
      <category term="jenkins" scheme="http://www.huckops.xyz/categories/jenkins/"/>
    
    
      <category term="自动化运维技术" scheme="http://www.huckops.xyz/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>redis/创建redis集群</title>
    <link href="http://www.huckops.xyz/2020/03/12/redis/%E5%88%9B%E5%BB%BAredis%E9%9B%86%E7%BE%A4/"/>
    <id>http://www.huckops.xyz/2020/03/12/redis/%E5%88%9B%E5%BB%BAredis%E9%9B%86%E7%BE%A4/</id>
    <published>2020-03-12T11:11:56.850Z</published>
    <updated>2020-03-12T12:13:00.390Z</updated>
    
    <content type="html"><![CDATA[<p>redis集群和哨兵的用途相似，但是集群更适合用于生产。其具有以下优势：</p><ol><li>数据自动切片分布到节点上</li><li>节点挂掉的适合，其他节点可以顶上</li></ol><p>节点内服务器分别负责处理不同hash端的数据。利用CRC16的算法，对key进行分发处理。</p><p>当创建完成一个集群后，集群负责处理的hash段的顶是固定的，所以当增加节点的时候，这个节点的hash段将分别从各个节点的底部去一部分，凑成一个新节点。</p><p>目前的集群架构，最低需要3Master和3Slave。这几个节点互相为主从结构，将数据分布储存，并进行主从复制。</p><h1 id="Redis节点一致性"><a href="#Redis节点一致性" class="headerlink" title="Redis节点一致性"></a>Redis节点一致性</h1><p>节点间的复制原理如下：</p><ol><li>cli向一台主机发送写指令</li><li>主机向cli发送一个状态</li><li>主机将请求分发给其他主机</li></ol><p>这是一种异步写操作，其他主机复制时候，可能会发生数据不一致的情况。</p><h1 id="redis集群搭建"><a href="#redis集群搭建" class="headerlink" title="redis集群搭建"></a>redis集群搭建</h1><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>下载redis的源码文件，进行编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># wget http://download.redis.io/releases/redis-3.2.9.tar.gz</span></span><br><span class="line">bash<span class="comment"># tar -zxvf redis-3.2.9.tar.gz</span></span><br><span class="line">bash<span class="comment"># cd redis-3.2.9</span></span><br></pre></td></tr></table></figure><p>redis编译需要gcc和tcl的支持，手动安装一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># yum install gcc tcl</span></span><br></pre></td></tr></table></figure><p>编译安装一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># make &amp;&amp; make PREFIX=/usr/local/redis</span></span><br></pre></td></tr></table></figure><p>通常情况下，redis集群由多台服务器组成，每台服务器上也会跑多个数据节点。在这里，一个进程被看作了一个节点，只要节点监听的端口不发生冲突，那么就可以一台主机开多个节点了。</p><p>创建redis的配置文件（多节点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># mkdir &#123;7000..7005&#125;</span></span><br><span class="line">bash<span class="comment"># touch &#123;7000..7005&#125;/redis.conf</span></span><br></pre></td></tr></table></figure><p>这里只是创建了一个空白的redis配置文件，当然，咱们也可以使用软件自带的配置文件进行修改。</p><p>在配置文件中，打开集群配置，修改pid、aof和rdb的位置，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">port 7000</span><br><span class="line"># 后台启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line">#集群节点配置文件</span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"># 集群连接超时时间</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"># 进程pid的文件位置</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis-7000.pid</span><br><span class="line"># 开启aof</span><br><span class="line">appendonly yes</span><br><span class="line"># aof文件路径</span><br><span class="line">appendfilename &quot;appendonly-7005.aof&quot;</span><br><span class="line"># rdb文件路径</span><br><span class="line">dbfilename dump-7000.rdb</span><br></pre></td></tr></table></figure><p>启动集群内节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># bin/redis-server cluster/7000/redis.conf</span></span><br></pre></td></tr></table></figure><p>使用官方的redis-trib.rb工具生成集群，但是这个工具使用了ruby的环境，我们先配置好ruby的环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># yum install ruby rubygems -y</span></span><br><span class="line">bash<span class="comment"># gem install redis</span></span><br></pre></td></tr></table></figure><p>创建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span></span><br></pre></td></tr></table></figure><p>自动创建集群。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>使用redis-cli进行节点验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> a 5</span><br><span class="line">-&gt; Redirected to slot [15495] located at 127.0.0.1:7005</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7005&gt; get a</span><br><span class="line"><span class="string">"5"</span></span><br><span class="line">127.0.0.1:7005&gt; <span class="built_in">set</span> szac sa </span><br><span class="line">-&gt; Redirected to slot [8894] located at 127.0.0.1:7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt; get szac</span><br><span class="line"><span class="string">"sa"</span></span><br></pre></td></tr></table></figure><p>可以看出来，发生了节点漂移，就是集群成功了。</p><h1 id="模拟宕机检验"><a href="#模拟宕机检验" class="headerlink" title="模拟宕机检验"></a>模拟宕机检验</h1><p>我们先看一下redis的健康监测工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># ./redis-trib.rb check 127.0.0.1:7001</span></span><br></pre></td></tr></table></figure><p>redis-trib.rb不仅提供了集群组件方案，也提供了集群的健康监测方案。这一段就是进行了健康监测。</p><p>这一段命令会返回当前的所有在线的节点，我们先挂掉7000节点看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># ./redis-trib.rb check 127.0.0.1:7001</span></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span><br><span class="line">M: 315e2abf264b2437b0ba859483adcc7fd81d2655 127.0.0.1:7001</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 68ba481a27f25ef8eecc15bfd6e32fbd579fda79 127.0.0.1:7003</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">M: 3ac136984eb0d24dfcb057da36f39a0fa71752a0 127.0.0.1:7005</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 5b5385b9885c1116dd956dc393909d9eabcbfe10 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 315e2abf264b2437b0ba859483adcc7fd81d2655</span><br><span class="line">S: 63f3ee573957e786cf1395cb21086ed445afd5ca 127.0.0.1:7002</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 3ac136984eb0d24dfcb057da36f39a0fa71752a0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><p>这里的集群自动割除了那个挂掉的节点，当前的服务器工作仍然正常，这就保证了数据的高可用。</p><p>重新启动刚才挂掉的服务，在进行监测，会发现集群内又出现了这个节点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis集群和哨兵的用途相似，但是集群更适合用于生产。其具有以下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据自动切片分布到节点上&lt;/li&gt;
&lt;li&gt;节点挂掉的适合，其他节点可以顶上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;节点内服务器分别负责处理不同hash端的数据。利用CRC16的算法，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>gzip模块</title>
    <link href="http://www.huckops.xyz/2020/03/09/Nginx%E8%B0%83%E4%BC%98/gzip%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.huckops.xyz/2020/03/09/Nginx%E8%B0%83%E4%BC%98/gzip%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-09T15:21:07.000Z</published>
    <updated>2020-03-09T15:39:25.683Z</updated>
    
    <content type="html"><![CDATA[<p>Gzip是nginx内置的一个压缩模块，对发送的数据进行压缩，在质量和速度上取得一个折中，提高服务的性能。</p><p>Gzip通常被写到server块中，下边看一看这个模块的写法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gzip off;</span><br><span class="line"></span><br><span class="line">gzip_min_length 1k;</span><br><span class="line"></span><br><span class="line">gzip_comp_level 1;</span><br><span class="line"></span><br><span class="line">gzip_types text&#x2F;plain application&#x2F;javascript application&#x2F;x-javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png application&#x2F;vnd.ms-fontobject font&#x2F;ttf font&#x2F;opentype font&#x2F;x-woff image&#x2F;svg+xml;</span><br><span class="line"></span><br><span class="line">gzip_vary on;</span><br><span class="line"></span><br><span class="line">gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line">gzip_buffers 32 4k;</span><br><span class="line"></span><br><span class="line">gzip_http_version 1.0;</span><br></pre></td></tr></table></figure><p>这是gzip常用的几个配置，从上往下看：</p><p>gzip on|off： 这是控制gzip开关的字段。相当于开关。</p><p>gzip_min_length： 设置了压缩的最小文件长度。通常来说，小文件是不需要进行压缩的，压缩后反而会降低原本的质量。所以需要设置一个最小压缩下限，防止小文件按被压缩。</p><p>gzip_comp_level：压缩等级。这个压缩等级需要根据实际的需求改。不推荐一次设置的很高，这样反而会降低网站的质量。</p><p>gzip_type：压缩格式。一般的说，所有静态资源都是浏览器向nginx服务器请求获得的，当服务器接收到不同的文件请求时，需要进行不同的压缩方案。这里就设置了需要压缩的格式。</p><p>gzip_vary： 在header中加入vary字段。</p><p>gzip_disable： 设置不进行压缩的请求头。有浏览器和gzip时不兼容的，这里通常会禁用ie的gzip。</p><p>gzip_buffer：压缩缓冲区。作用就是对压缩的文件进行缓冲加载。</p><p>gzip_http_version： 压缩的http请求版本。有1.0和1.1.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gzip是nginx内置的一个压缩模块，对发送的数据进行压缩，在质量和速度上取得一个折中，提高服务的性能。&lt;/p&gt;
&lt;p&gt;Gzip通常被写到server块中，下边看一看这个模块的写法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
    
      <category term="Nginx" scheme="http://www.huckops.xyz/categories/Nginx/"/>
    
    
      <category term="http服务器" scheme="http://www.huckops.xyz/tags/http%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器性能指标</title>
    <link href="http://www.huckops.xyz/2020/03/09/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <id>http://www.huckops.xyz/2020/03/09/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</id>
    <published>2020-03-09T07:39:25.000Z</published>
    <updated>2020-03-09T08:36:13.153Z</updated>
    
    <content type="html"><![CDATA[<p>Linux服务器和大部分PC机一样，都有CPU、内存、硬盘和主板等部件构成。服务器特有阵列卡，是为冗余储存设计的，制约服务器性能的参数有一下几条：</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>CPU是服务器的核心。目前服务器CPU常用英特尔至强系列，英特尔E7系列服务器CPU是当前比较高性能的CPU了。服务器一般情况下是使用的双CPU，有的甚至使用多个CPU。一般的来说，服务器有一个CPU就可以完成运算了，但是为了追求算力的最大化和服务的稳定性，通常会使用到双CPU或者多CPU。主板搭载多CPU时，这些CPU会进行并行运算，从而获得最大的算力。</p><p>我们可以在/dev/cpu查看cpu硬件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># ll /dev/cpu</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root      80 Mar  3 18:09 0</span><br><span class="line">drwxr-xr-x 2 root root      80 Mar  3 18:09 1</span><br><span class="line">crw------- 1 root root 10, 184 Mar  3 18:09 microcode</span><br></pre></td></tr></table></figure><p>这里展现了cpu的硬件。</p><p>我们可以通过查看/proc/cpuinfo文件来查询CPU的具体情况。</p><p>下边介绍一下CPU的技术指标：</p><h2 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h2><p>CPU频率就是通常意义上的数据处理频率。一般情况下，CPU频率越高，CPU的运算能力越强。但是通常会因为温度问题制约CPU的性能。所以，CPU的降温非常重要。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>一般情况下，CPU时会设计有三级缓存的，这三级缓存主要时用做内存和CPU之间的数据通信缓冲的。</p><p>那么，从这一点就不难得出，当CPU的频率较高时，一定有较大的缓存，一般的说，CPU频率越高，内存也会给的越大。</p><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>虚拟化技术时服务器上最常用到的。目前各大厂商的云计算服务器都推崇虚拟化。虚拟化的依赖就是CPU的虚拟化技术。一般来说，英特尔至强系列的CPU都会支持intel-VT技术，保障虚拟化的实施。</p><h2 id="物理核和逻辑核"><a href="#物理核和逻辑核" class="headerlink" title="物理核和逻辑核"></a>物理核和逻辑核</h2><p>咱们经常会听到有人说几何几线程。这里的核就是物理核，线程就是逻辑核。通常来说，逻辑核是物理核的二倍。就这一点我们就可以得出一个结论，逻辑核是由物理核模拟出来的。</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>内存也是服务器的一个重要组成部分。根据冯诺依曼的结构理论来说，内存的大小和质量也直接的影响了设备对数据的处理能力。</p><p>我们的PC机，目前用的内存是常规没有ECC的内存，价格较高，频率也比较高，一般不会低于2000MHz。服务器用的内存条是ECC内存条，相比于PC机用的内存，更廉价，频率更低。单从稳定性和容量上，服务器就不可能选用普通内存。</p><p>下边是内存的几个技术指标：</p><h2 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h2><p>就是我们通常理解的容量。服务器的内存容量都是非常大的，一台主机可能都会由及时G的样子。</p><h2 id="频率-1"><a href="#频率-1" class="headerlink" title="频率"></a>频率</h2><p>内存的频率和CPU的有些类似，我就不单说了。</p><blockquote><p><strong>插入知识：swap</strong><br>swap叫内存交换区。这个交换区有点像一个缓冲区。当内存的性能不能匹配CPU的处理速度的时候，会使用swap来进行缓冲。<br>swap是基于硬盘的，所以数据的存储效率可能会低于内存。</p></blockquote><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>通常的服务器集群中，都不会直接把数据存放到业务服务器上，都是将数据存放在数据存储集群的。数据存储集群也依赖于硬盘，硬盘的效率对服务器的快速性也由很大的影响。</p><h2 id="硬盘容量"><a href="#硬盘容量" class="headerlink" title="硬盘容量"></a>硬盘容量</h2><p>即为硬盘的大小，没有什么需要说的。</p><h2 id="硬盘缓存"><a href="#硬盘缓存" class="headerlink" title="硬盘缓存"></a>硬盘缓存</h2><p>和CPU缓存的原理一样，不多赘述。</p><h2 id="SAS和SATA"><a href="#SAS和SATA" class="headerlink" title="SAS和SATA"></a>SAS和SATA</h2><p>这是两种硬盘的接口方式。SAS硬盘常用于服务器上，SATA硬盘常用于PC机上，就稳定性而言，SAS略胜一筹。</p><h2 id="SSD和HDD"><a href="#SSD和HDD" class="headerlink" title="SSD和HDD"></a>SSD和HDD</h2><p>SSD被称为固态硬盘，HDD被称为机械硬盘。固态硬盘很少有用在服务器上，原因是企业级的SSD成本非常高，而且当数据丢失的时候不易于恢复，基本丢数据就是永久性的。</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>数据吞吐量，即I/O。一般意义上I/O越大，效果就越好，服务器的处理速度就越快。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>网络是体统服务的媒介，网络的速度直接影响客户的体验。目四七年机房采用的网络模式基本都是专线接入，超大带宽。下边是几个网络的技术参数：</p><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>网络都会有延迟，这个延迟的时间取决于客户端和服务器之间网关的响应时间。如果是跨运营商访问，那么访问的延迟一般都会比较大。</p><h2 id="吞吐量-1"><a href="#吞吐量-1" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>就是广泛意义上的网速。</p><h2 id="百千万兆"><a href="#百千万兆" class="headerlink" title="百千万兆"></a>百千万兆</h2><p>这个表示的不是网络带宽，指的是网络的模式。这个单位是Mbps。网络模式要和网卡，网线，交换机设备都匹配才能体现出最佳性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux服务器和大部分PC机一样，都有CPU、内存、硬盘和主板等部件构成。服务器特有阵列卡，是为冗余储存设计的，制约服务器性能的参数有一下几条：&lt;/p&gt;
&lt;h1 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;
      
    
    </summary>
    
    
      <category term="业务理论" scheme="http://www.huckops.xyz/categories/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="业务理论" scheme="http://www.huckops.xyz/tags/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>镜像</title>
    <link href="http://www.huckops.xyz/2020/03/08/docker/%E9%95%9C%E5%83%8F/"/>
    <id>http://www.huckops.xyz/2020/03/08/docker/%E9%95%9C%E5%83%8F/</id>
    <published>2020-03-08T12:19:13.893Z</published>
    <updated>2020-03-08T11:39:35.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>镜像是被封装好的服务，镜像可以随时调用，方便进行部署。镜像可以是docker hub上的，也可以是自己封装的。</p></blockquote><p>咱们看一下系统镜像的组成</p><p><img src="img/docker-filesystems-multilayer.png" alt=""></p><p>可以认为镜像都是多镜像叠加起来的。</p><p>咱们要部署环境，第一件事就是查找相关镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search image_name:tag</span><br></pre></td></tr></table></figure><p>系统会返回相关的镜像信息，咱们以centos为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@server etc]# docker search centos</span><br><span class="line">INDEX       NAME                                         DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io&#x2F;centos                             The official build of CentOS.                   5703      [OK]</span><br><span class="line">docker.io   docker.io&#x2F;ansible&#x2F;centos7-ansible            Ansible on Centos7                              126                  [OK]</span><br></pre></td></tr></table></figure><p>看一下返回的东西。INDEX是镜像库，NAME是镜像名，DESCRIPTION是镜像简介，OFFICIAL表示是否官方镜像，AUTOMATED表示自动部署。</p><p>咱们再看看搜索命令，image_name后有tag，一般情况下，tag表示的是镜像的版本，但是也有其他的用途。</p><p>获取到镜像信息了，咱们可以拉取镜像了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull image_name:tag</span><br></pre></td></tr></table></figure><p>咱们再这里发现，拉取镜像的时候有多个拉取进度条，这就可以说明，镜像是多个镜像叠加成的。</p><p>拉取镜像和查询镜像的时候，可以不要tag。如果不要tag的话，那就是拉取最新的镜像，及默认latest。</p><p>拉取镜像到本地后，咱们可以查看以下本地的镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/centos    latest              0f3e07c0138f        2 months ago        220 MB</span><br></pre></td></tr></table></figure><p>看看这个列表。</p><p>REPOSITORY表示镜像来源，TAG表示镜像的标签。</p><p>IMAGE ID这个参数很重要。每个镜像都会分配一个image id，且唯一。这个image id是拉取镜像的时候系统给分配的。所以再docker hub上是没有分配image id的。</p><p>CREATED表示拉取镜像的时间，是拉取镜像到现在的时长。SIZE表示镜像的大小。</p><p><strong>咱们看看这个SIZE。一个完整的centos大概需要6G左右，但是这里只有200M左右，且能完成基本的服务功能。这就体现出了容器化相对于虚拟化的优越性了。</strong></p><p>运行以下镜像吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd 0f3e07c0138f</span><br></pre></td></tr></table></figure><p>镜像这样就运行起来了，咱们看一下状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d24f69f87efb        0f3e07c0138f        <span class="string">"/bin/bash"</span>         4 seconds ago       Up 2 seconds</span><br></pre></td></tr></table></figure><p>运行成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;镜像是被封装好的服务，镜像可以随时调用，方便进行部署。镜像可以是docker hub上的，也可以是自己封装的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;咱们看一下系统镜像的组成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/docker-filesy
      
    
    </summary>
    
    
      <category term="docker" scheme="http://www.huckops.xyz/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="http://www.huckops.xyz/2020/03/08/docker/%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.huckops.xyz/2020/03/08/docker/%E7%BD%91%E7%BB%9C/</id>
    <published>2020-03-08T12:19:13.888Z</published>
    <updated>2020-03-08T11:40:50.642Z</updated>
    
    <content type="html"><![CDATA[<p>docker网络默认时使用NAT模式的，结构图如下</p><p><img src="img/1529328359399810.png" alt=""></p><p>这张图上有两种模式。第一个容器是host模式，该容器的的IP和主机是相同的，和主机共享网络。第二个是bridge模式。</p><p>主要说一下bridge模式。</p><p>在docker内部，软件会生成一个虚拟网关，形成一个虚拟的网络。容器分配的IP是这个虚拟网关分配的。外网无法访问，除非在创建容器的时候创建端口映射。</p><h1 id="查看docker网络"><a href="#查看docker网络" class="headerlink" title="查看docker网络"></a>查看docker网络</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">194c884755b2        bridge              bridge              <span class="built_in">local</span></span><br><span class="line">ee717ffaa64f        host                host                <span class="built_in">local</span></span><br><span class="line">f39060423673        none                null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>上边是docker的三种网络模式。</p><p>在主机上执行ip add命令可以发现一条信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default</span><br><span class="line">    link&#x2F;ether 02:42:98:a4:a1:70 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1&#x2F;16 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:98ff:fea4:a170&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>这是docker创建的虚拟网卡，这里以虚拟网卡为网关。</p><h2 id="bridge通信原理"><a href="#bridge通信原理" class="headerlink" title="bridge通信原理"></a>bridge通信原理</h2><p>容器将数据发送到虚拟网卡上，然后通过虚拟网卡发送出去。外网访问也是同理。</p><h1 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h1><p>因为有虚拟网络存在，所以外网因为有内网隔离无法访问到容器。我们需要添加端口映射。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -p 主机端口:容器端口 image_id</span><br></pre></td></tr></table></figure><p>这样的话外网就可以访问到相应的端口了。</p><p>也可所以使用-P参数，就是随机分配端口。</p><h1 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h1><p>创建容器时添加–link参数，在新容器的hosts文件添加原容器的解析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;docker网络默认时使用NAT模式的，结构图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;img/1529328359399810.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这张图上有两种模式。第一个容器是host模式，该容器的的IP和主机是相同的，和主机共享网络。第二个是bri
      
    
    </summary>
    
    
      <category term="docker" scheme="http://www.huckops.xyz/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数据卷</title>
    <link href="http://www.huckops.xyz/2020/03/08/docker/%E6%95%B0%E6%8D%AE%E5%8D%B7/"/>
    <id>http://www.huckops.xyz/2020/03/08/docker/%E6%95%B0%E6%8D%AE%E5%8D%B7/</id>
    <published>2020-03-08T12:19:13.878Z</published>
    <updated>2020-03-08T11:40:16.117Z</updated>
    
    <content type="html"><![CDATA[<p>数据卷可将主机和容器之间做文件上的连接，更便于容器中的文件管理。</p><h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>添加数据卷。在创建容器的时候添加-v参数，即可添加数据卷。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd -v 本地目录:容器目录 image_id</span><br></pre></td></tr></table></figure><p>这里可以不写容器目录，如果不写的话是给容器加载了数据卷，但是不挂载。如果加容器目录则加载到容器内。</p><p>目录可以改成文件，则是文件挂载。</p><h1 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h1><p>数据卷容器时一个容器，就是把容器作为数据卷挂载到新容器。</p><p>创建数据卷容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><p>挂载数据卷容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from dbdata --name db1 ubuntu</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据卷可将主机和容器之间做文件上的连接，更便于容器中的文件管理。&lt;/p&gt;
&lt;h1 id=&quot;数据卷&quot;&gt;&lt;a href=&quot;#数据卷&quot; class=&quot;headerlink&quot; title=&quot;数据卷&quot;&gt;&lt;/a&gt;数据卷&lt;/h1&gt;&lt;p&gt;添加数据卷。在创建容器的时候添加-v参数，即可添加数
      
    
    </summary>
    
    
      <category term="docker" scheme="http://www.huckops.xyz/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="http://www.huckops.xyz/2020/03/08/docker/%E5%AE%B9%E5%99%A8/"/>
    <id>http://www.huckops.xyz/2020/03/08/docker/%E5%AE%B9%E5%99%A8/</id>
    <published>2020-03-08T12:19:13.868Z</published>
    <updated>2020-03-08T11:39:53.104Z</updated>
    
    <content type="html"><![CDATA[<p>容器就是镜像跑起来之后的东西。容器之间可以互相访问，但是和实环境隔离。</p><p>咱们看一下运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d24f69f87efb        0f3e07c0138f        <span class="string">"/bin/bash"</span>         6 hours ago         Up 6 seconds                            epic_bose</span><br></pre></td></tr></table></figure><p>看一下上边的参数。</p><p>CONTAINER ID 容器的ID号。</p><p>IMAGE 容器的来源镜像ID。</p><p>COMMAND 容器运行时候的命令。</p><p>CREATED 创建时间。</p><p>PORTS 端口映射。</p><p>NAMES 容器名。</p><h1 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h1><p>容器由镜像创建来，且一直保存。则容器往往会有运行和停止两个状态。</p><p>启动容器<code>docker start CONTAINER ID</code></p><p>停止容器<code>docker stop CONTAINER ID</code></p><p>有时候咱们启动容器了，但是发现查看容器的时候还是有问题，不能启动。一般情况下，容器不会没有原因的无法启动，肯定是出问题了，那么就看看容器的日志。</p><figure class="highlight docker"><figcaption><span>logs CONTAINER ID```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">分析一下日志信息，按照信息报的错误修改配置。</span><br><span class="line"></span><br><span class="line">容器也不是永远都有用的，所以有时候我们会删除有些容器。</span><br><span class="line"></span><br><span class="line">```docker rm CONTAINER ID</span><br></pre></td></tr></table></figure><p><strong>注意：运行中的容器不能删除，所以一般情况需要停止容器才能删除。如果要强制删除的话直接加参数-f就好了。</strong></p><h1 id="文件交互"><a href="#文件交互" class="headerlink" title="文件交互"></a>文件交互</h1><p>有时候需要将物理机上的文件拷贝到容器中，有时候需要将容器中的文件拷贝到本地。这个直接使用docker的拷贝功能就好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp file CONTAINER_ID:file <span class="comment">#本地复制到容器</span></span><br><span class="line">docker cp CONTAINER_ID:file file <span class="comment">#容器复制到本地</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;容器就是镜像跑起来之后的东西。容器之间可以互相访问，但是和实环境隔离。&lt;/p&gt;
&lt;p&gt;咱们看一下运行的容器：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="docker" scheme="http://www.huckops.xyz/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>docker的安装和配置</title>
    <link href="http://www.huckops.xyz/2020/03/08/docker/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.huckops.xyz/2020/03/08/docker/docker%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-03-08T12:19:13.863Z</published>
    <updated>2020-03-08T11:39:11.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Docker是目前容器化的常用软件，它可以隔离真是主机环境，且上线环境部署容易，容灾性高。</p></blockquote><h1 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h1><p>docker可以通过yum进行安装，安装方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装后，咱们最好更改一下docker的加速源，修改<code>/etc/docker/daemon.json</code>，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启以下docker服务就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Docker是目前容器化的常用软件，它可以隔离真是主机环境，且上线环境部署容易，容灾性高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境
      
    
    </summary>
    
    
      <category term="docker" scheme="http://www.huckops.xyz/categories/docker/"/>
    
    
      <category term="容器技术" scheme="http://www.huckops.xyz/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>模块</title>
    <link href="http://www.huckops.xyz/2020/03/08/ansible/%E6%A8%A1%E5%9D%97/"/>
    <id>http://www.huckops.xyz/2020/03/08/ansible/%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-08T12:19:13.840Z</published>
    <updated>2020-03-08T11:35:59.368Z</updated>
    
    <content type="html"><![CDATA[<p>ansible 和 saltstack 相似，都是调用相关模块实现功能的，有一些模块是我们很常用的。</p><p>这里调用模块的方法和 saltstack 不同，需要使用 -m 参数进行调用。</p><h1 id="ping-模块"><a href="#ping-模块" class="headerlink" title="ping 模块"></a>ping 模块</h1><p>和广义上的 ping 意义相似，都是进行主机连通性测试的，检查群内主机是否在线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s1 log]# ansible all -m ping </span><br><span class="line">192.168.89.130 | SUCCESS &#x3D;&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.168.89.129 | SUCCESS &#x3D;&gt; &#123;</span><br><span class="line">    &quot;ansible_facts&quot;: &#123;</span><br><span class="line">        &quot;discovered_interpreter_python&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;python&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现success就说明主机是在线的。</p><h1 id="command-模块"><a href="#command-模块" class="headerlink" title="command 模块"></a>command 模块</h1><p>自动化操作基本都是基于ssh远程操作的shell指令的，我们会经常使用shell语句进行系统的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s1 log]# ansible test -m command -a &#39;ls -al &#x2F;root&#39;</span><br><span class="line">192.168.89.130 | CHANGED | rc&#x3D;0 &gt;&gt;</span><br><span class="line">总用量 80</span><br><span class="line">dr-xr-x---.  5 root root  4096 1月  27 18:55 .</span><br><span class="line">dr-xr-xr-x. 17 root root   244 1月  27 18:49 ..</span><br><span class="line">-rw-------.  1 root root  1253 1月  27 16:07 anaconda-ks.cfg</span><br><span class="line">...</span><br><span class="line">-rw-r--r--.  1 root root   129 12月 29 2013 .tcshrc</span><br><span class="line"></span><br><span class="line">192.168.89.129 | CHANGED | rc&#x3D;0 &gt;&gt;</span><br><span class="line">总用量 68</span><br><span class="line">dr-xr-x---.  7 root root  4096 1月  27 20:00 .</span><br><span class="line">dr-xr-xr-x. 17 root root   244 1月  27 18:49 ..</span><br><span class="line">-rw-------.  1 root root  1253 1月  27 16:07 anaconda-ks.cfg</span><br><span class="line">...</span><br><span class="line">-rw-------   1 root root  1261 1月  27 20:00 .viminfo</span><br></pre></td></tr></table></figure><p>调用command模块后，使用-a参数传入要运行的shell语句。</p><p>有时候因为我们没有root权限，或者有些文件不能用root进行操作，那么我们会用到其他账户，使用 -u 参数有指定账户。</p><p>command模块的几个功能：</p><ol><li>removes：存在条件判断，当文件存在时运行后边的命令。</li><li>creates：不存在条件判断，当文件不存在的时候执行后边的命令。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s1 ~]# ansible all -a &#39;creates&#x3D;&#x2F;root&#x2F;setup.log cat &#x2F;root&#x2F;setup.log&#39;</span><br><span class="line">192.168.89.129 | SUCCESS | rc&#x3D;0 &gt;&gt;</span><br><span class="line">skipped, since &#x2F;root&#x2F;setup.log exists</span><br><span class="line"></span><br><span class="line">192.168.89.130 | SUCCESS | rc&#x3D;0 &gt;&gt;</span><br><span class="line">skipped, since &#x2F;root&#x2F;setup.log exists</span><br></pre></td></tr></table></figure><p>从以上文本可以看出，存在就不执行。</p><h2 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h2><p>这是标准的shell模块，和command相似，但是shell对于linux更专业，所以执行远程命令更推荐使用shell模块。</p><p>command模块不支持管道符，但是shell模块可以使用。</p><h1 id="Script-模块"><a href="#Script-模块" class="headerlink" title="Script 模块"></a>Script 模块</h1><p>一般情况下运行脚本需要将脚本文件分发到各主机上分别进行运行，这样很不方便，在ansible中我们使用了script模块，只需要在master主机上编辑脚本就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash# ansible all -m script -a &#39;&#x2F;root&#x2F;test.sh&#39;</span><br></pre></td></tr></table></figure><p>这样就分别在主机上执行了test.sh脚本，输出格式有普通输出和格式化输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;stdout&quot;: &quot;k8s1\r\n&quot;, </span><br><span class="line">&quot;stdout_lines&quot;: [</span><br><span class="line">    &quot;k8s1&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="copy-模块"><a href="#copy-模块" class="headerlink" title="copy 模块"></a>copy 模块</h1><p>就是复制模块，需要进行目标文件和目的的指定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m copy -a &#39;src&#x3D;&#x2F;root&#x2F;test.sh dest&#x3D;&#x2F;tmp owner&#x3D;root group&#x3D;root mode&#x3D;0755&#39;</span><br></pre></td></tr></table></figure><p>这样就把文件以复制的方式分发给了主机。前提：master上存在这个文件。指定为src，目的指定为dest。</p><h1 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h1><p>yum模块是只针对于Centos的安装模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m yum -a &#39;name&#x3D;vim state&#x3D;latest&#39;</span><br></pre></td></tr></table></figure><p>上边这一段命令就给主机安装了vim编辑器。</p><h1 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a>service模块</h1><p>服务器的主要功能就是服务，服务器系统主要任务就是提供服务。我们经常会对集群内服务进行操作，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible all -m service -a &#39;name&#x3D;nginx state&#x3D;started&#39;</span><br></pre></td></tr></table></figure><p>这段命令启动了nginx。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ansible 和 saltstack 相似，都是调用相关模块实现功能的，有一些模块是我们很常用的。&lt;/p&gt;
&lt;p&gt;这里调用模块的方法和 saltstack 不同，需要使用 -m 参数进行调用。&lt;/p&gt;
&lt;h1 id=&quot;ping-模块&quot;&gt;&lt;a href=&quot;#ping-模块&quot;
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://www.huckops.xyz/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://www.huckops.xyz/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>主机管理</title>
    <link href="http://www.huckops.xyz/2020/03/08/ansible/%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86/"/>
    <id>http://www.huckops.xyz/2020/03/08/ansible/%E4%B8%BB%E6%9C%BA%E7%AE%A1%E7%90%86/</id>
    <published>2020-03-08T12:19:13.835Z</published>
    <updated>2020-03-08T11:36:22.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分组管理"><a href="#分组管理" class="headerlink" title="分组管理"></a>分组管理</h1><p>在大型集群里，机器会分为多个可用域，每个可用域做的业务也不相同，执行的命令和在集群中承担的角色也不同，那就需要进行分组管理。</p><h2 id="创建分组："><a href="#创建分组：" class="headerlink" title="创建分组："></a>创建分组：</h2><p>在/etc/ansible/hosts文件下创建之际和组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[group]</span><br><span class="line">host</span><br></pre></td></tr></table></figure><p>这样就创建了一个管理组。</p><p>需要注意，ansible是基于ssh的集群管理工具，默认的链接端口是22，如果主机的ssh端口被修改过，则在声明hosts的时候著名ssh的端口。</p><p>有时候服务器的使用账户并非root，那就需要进行指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[group]</span><br><span class="line">host ansible_connection&#x3D;connect_method ansible_ssh_user&#x3D;user</span><br></pre></td></tr></table></figure><p>这样来指定ssh连接方式和连接的用户名。</p><h2 id="创建变量"><a href="#创建变量" class="headerlink" title="创建变量"></a>创建变量</h2><p>有时候需要给服务器增加一个变量或者标志，那么就在<br>hosts文件上添加变量即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[group]</span><br><span class="line">host var&#x3D;value</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分组管理&quot;&gt;&lt;a href=&quot;#分组管理&quot; class=&quot;headerlink&quot; title=&quot;分组管理&quot;&gt;&lt;/a&gt;分组管理&lt;/h1&gt;&lt;p&gt;在大型集群里，机器会分为多个可用域，每个可用域做的业务也不相同，执行的命令和在集群中承担的角色也不同，那就需要进行分组管理。
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://www.huckops.xyz/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://www.huckops.xyz/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>playbook</title>
    <link href="http://www.huckops.xyz/2020/03/08/ansible/playbook/"/>
    <id>http://www.huckops.xyz/2020/03/08/ansible/playbook/</id>
    <published>2020-03-08T12:19:13.830Z</published>
    <updated>2020-03-08T11:35:29.863Z</updated>
    
    <content type="html"><![CDATA[<p>playbook就是和saltstack类似的yaml部署描述文件。一个playbooks内包含一个或多个play，下面对play进行一下解析：</p><p>下边是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: webservers</span><br><span class="line">  vars:</span><br><span class="line">    http_port: 80</span><br><span class="line">    max_clients: 200</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: ensure apache is at the latest version</span><br><span class="line">    yum: pkg&#x3D;httpd state&#x3D;latest</span><br><span class="line">  - name: write the apache config file</span><br><span class="line">    template: src&#x3D;&#x2F;srv&#x2F;httpd.j2 dest&#x3D;&#x2F;etc&#x2F;httpd.conf</span><br><span class="line">    notify:</span><br><span class="line">    - restart apache</span><br><span class="line">  - name: ensure apache is running</span><br><span class="line">    service: name&#x3D;httpd state&#x3D;started</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service: name&#x3D;httpd state&#x3D;restarted</span><br></pre></td></tr></table></figure><h1 id="指定机器"><a href="#指定机器" class="headerlink" title="指定机器"></a>指定机器</h1><p>在yaml的前半段是对机器、用户和组的配置。</p><ul><li>hosts：指定执行的机器或者组</li><li>remote_user：运行的用户</li></ul><p>** 这里可以添加sudo: yes语句，表示使用sudo执行操作**</p><ul><li>vars：创建变量表</li></ul><h1 id="tasks-表"><a href="#tasks-表" class="headerlink" title="tasks 表"></a>tasks 表</h1><p>tasks表就是任务表，每个数据元素就是一个任务。</p><p>这是一个简单的nginx自动构建playbook。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- hosts: test</span><br><span class="line">  vars:</span><br><span class="line">    httpport: 80</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install nginx</span><br><span class="line">      yum: pkg&#x3D;nginx state&#x3D;latest</span><br><span class="line">    - name: start nginx</span><br><span class="line">      service: name&#x3D;nginx state&#x3D;started</span><br></pre></td></tr></table></figure><p>这个文件包含了两个task。</p><p>第一个是安装nginx，直接调用yum，用pkg key指定安装nginx，用state指定安装的版本。</p><p>第二个是服务状态控制。安装完成后nginx的状态是关闭的，需要进行手动启动。这里使用了service模块进行了自动启动。在name中指定服务名，在state中指定服务状态。</p><p>这里要注意，service指定的state必须是reload，started或者stopped，其他状态都是无效的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;playbook就是和saltstack类似的yaml部署描述文件。一个playbooks内包含一个或多个play，下面对play进行一下解析：&lt;/p&gt;
&lt;p&gt;下边是一个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://www.huckops.xyz/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://www.huckops.xyz/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ansible安装</title>
    <link href="http://www.huckops.xyz/2020/03/08/ansible/ansible%E5%AE%89%E8%A3%85/"/>
    <id>http://www.huckops.xyz/2020/03/08/ansible/ansible%E5%AE%89%E8%A3%85/</id>
    <published>2020-03-08T12:19:13.826Z</published>
    <updated>2020-03-08T11:27:47.276Z</updated>
    
    <content type="html"><![CDATA[<p>ansible是一个基于SSH协议的自动化运维工具，通常使用的时候需要给其他主机配置免密登录，且只需要安装控制端。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在控制端安装依赖及主程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yum install epel-release</span><br><span class="line"></span><br><span class="line">yum install ansible</span><br></pre></td></tr></table></figure><p>也可以使用pip安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pip install ansible</span><br></pre></td></tr></table></figure><p>安装好后进行主机配置和远程配置。</p><p>在控制端配置/etc/ansible/hosts文件，在这个文件里可以使用ip，也可以使用hostname（那就需要使用hosts文件对主机进行解析或者DNS能进行解析）。</p><p><img src="img/1.png" alt="1.png"></p><p>生成SSH公钥，将公钥信息下发给被控制主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>可以看到，生成的rsa公钥被存放在~/.ssh/id_rsa.pub中，那么久需要将这个文件下发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub root@192.168.89.129</span><br></pre></td></tr></table></figure><p>这样就配置好了SSH免密登录。</p><p>对配置好的集群进行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">bash#</span><span class="bash"> ansible all -m ping</span></span><br><span class="line"></span><br><span class="line">192.168.89.130 | SUCCESS =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line"></span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    "changed": false,</span><br><span class="line"></span><br><span class="line">    "ping": "pong"</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">192.168.89.129 | SUCCESS =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    "ansible_facts": &#123;</span><br><span class="line"></span><br><span class="line">        "discovered_interpreter_python": "/usr/bin/python"</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    "changed": false,</span><br><span class="line"></span><br><span class="line">    "ping": "pong"</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条命令和saltstack的test.ping的用途相同，就是尝试进行服务器间的通信测试。这里的两条success表示测试正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ansible是一个基于SSH协议的自动化运维工具，通常使用的时候需要给其他主机配置免密登录，且只需要安装控制端。&lt;/p&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;在控制端安
      
    
    </summary>
    
    
      <category term="ansible" scheme="http://www.huckops.xyz/categories/ansible/"/>
    
    
      <category term="自动化运维技术" scheme="http://www.huckops.xyz/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>灰度发布</title>
    <link href="http://www.huckops.xyz/2020/03/08/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    <id>http://www.huckops.xyz/2020/03/08/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/</id>
    <published>2020-03-08T12:19:13.816Z</published>
    <updated>2020-03-08T15:24:50.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>灰度发布就是在黑和白之间发布网站。假设有一个黑区和白区。黑区使用旧版本的产品，白区发布新版本产品，然后对白区进行产品调研。如果白区没有什么意见，则可白区向黑区扩散。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>beta和正式版。对特定用户推送beta版本产品，进行使用状况调研，然后根据调研逐渐将beta转化为正式版。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;灰度发布就是在黑和白之间发布网站。假设有一个黑区和白区。黑区使用旧版本的产品，白区发布新版本产品，然后对白区进行产品调研。如果白区没有什么意
      
    
    </summary>
    
    
      <category term="业务理论" scheme="http://www.huckops.xyz/categories/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="业务理论" scheme="http://www.huckops.xyz/tags/%E4%B8%9A%E5%8A%A1%E7%90%86%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/虚拟化及磁盘</title>
    <link href="http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E7%A3%81%E7%9B%98/"/>
    <id>http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%8F%8A%E7%A3%81%E7%9B%98/</id>
    <published>2020-03-08T12:19:13.599Z</published>
    <updated>2020-01-13T11:22:49.369Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机，我们常叫做实例。一个实例就含一个最基本的服务器的最小系统，包括虚拟硬件系统和软件系统。</p><p>通常生产环节的服务器不适用GUI界面，但是再做KVM的时候，需要GUI界面做辅助管理，所以再安装KVM之前务必先安装桌面。</p><p><strong>KVM最终生成的配置文件是xml文件</strong></p><p>创建虚拟机时，使用命令<code>virt-install</code>创建KVM虚拟机。</p><p>常用参数：</p><ul><li>name：虚拟机名</li><li>vCPUs：虚拟CPU核心数</li><li>ram：虚拟内存大小</li><li>os-type：系统类型</li><li>cdrom：CD挂载的镜像文件</li><li>file：虚拟机硬盘文件</li><li>file-size：虚拟硬盘大小</li></ul><h1 id="虚拟硬盘"><a href="#虚拟硬盘" class="headerlink" title="虚拟硬盘"></a>虚拟硬盘</h1><p>通常情况，任何电脑想运行起来都得有硬盘做数据存储支持，所以，咱们先创建虚拟硬盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create xxx.qcow2 -f qcow2 size</span><br></pre></td></tr></table></figure><p>上述代码创建了一个qcow2格式的虚拟硬盘。</p><p>虚拟磁盘大概有两种类型，一个是IDE，一个是Virtio。根据读写数据测试，Virtio是性能最好的方案。</p><p>虚拟磁盘的格式也有很多种，用的最多的是qcow2格式的硬盘文件。</p><p>QEMU支持常见使用的raw和qcow2格式。</p><h1 id="硬盘虚拟化的主要操作"><a href="#硬盘虚拟化的主要操作" class="headerlink" title="硬盘虚拟化的主要操作"></a>硬盘虚拟化的主要操作</h1><h2 id="硬盘创建"><a href="#硬盘创建" class="headerlink" title="硬盘创建"></a>硬盘创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create test 50G</span><br></pre></td></tr></table></figure><p>创建一个50G的硬盘，但是没有写是什么格式。要实际使用必须给一个指定的硬盘格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create test.qcow2 -f qcow2 50G</span><br></pre></td></tr></table></figure><p>上边就是指定生成一个qcow2格式的硬盘。注意钱两段语句test有无后缀。</p><p>这里不写绝对地址，那么就再当前目录生成文件。</p><p>可以通过<code>qemu-img info test.qcow2</code>查看生成硬盘的信息。</p><h2 id="硬盘格式转换"><a href="#硬盘格式转换" class="headerlink" title="硬盘格式转换"></a>硬盘格式转换</h2><p>平时硬盘也就一两种格式常用，但是有时候也会使用其他格式，那么就需要进行转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img convert -p -f raw -O qcow2 test test1.qcow2</span><br></pre></td></tr></table></figure><p>#快照</p><p>快照就是系统在某一个瞬间被“抓拍”到的状态，这个状态可以随时进行恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot test.qcow2 -c s1</span><br></pre></td></tr></table></figure><p>以上代码创建了一个名为s1的快照，我们可以查看一下快照列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot test.qcow2 -l</span><br></pre></td></tr></table></figure><p>镜像是用来给特殊情况下给服务器做还原用的，所以必然就会用到还原，使用a参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img snapshot test.qcow2 -a s1</span><br></pre></td></tr></table></figure><h1 id="后备镜像"><a href="#后备镜像" class="headerlink" title="后备镜像"></a>后备镜像</h1><p>后备镜像就是常说的公有镜像，一个后备镜像可以做多个虚拟机的母盘。</p><p>后备（backend）使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 -b backend img_name</span><br></pre></td></tr></table></figure><p>使用后备磁盘创建一个虚拟硬盘。</p><h1 id="虚拟硬盘属性定义"><a href="#虚拟硬盘属性定义" class="headerlink" title="虚拟硬盘属性定义"></a>虚拟硬盘属性定义</h1><p>最常用的硬盘指标是容量，虚拟主机经常会出现硬盘不足，那么我们就需要手动再给加大硬盘了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img resize test1.qcow2 +2G</span><br></pre></td></tr></table></figure><p>这里是给元硬盘的基础加2G，当然也可以写成需要改到的大小。</p><h1 id="裸设备"><a href="#裸设备" class="headerlink" title="裸设备"></a>裸设备</h1><p>为让虚拟机获取极致的算力和性能，可以直接挂在裸硬盘到虚拟机。也可以使用lvm，但是lvm需要关闭cache，防止数据丢失。</p><h1 id="常用虚拟硬盘格式对比"><a href="#常用虚拟硬盘格式对比" class="headerlink" title="常用虚拟硬盘格式对比"></a>常用虚拟硬盘格式对比</h1><p>RAW：整体性能较高</p><p>qcow2：常见的虚拟硬盘格式，适合高消耗计算</p><p>lvm：适合高IO的计算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虚拟机，我们常叫做实例。一个实例就含一个最基本的服务器的最小系统，包括虚拟硬件系统和软件系统。&lt;/p&gt;
&lt;p&gt;通常生产环节的服务器不适用GUI界面，但是再做KVM的时候，需要GUI界面做辅助管理，所以再安装KVM之前务必先安装桌面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;KVM最终
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/网络虚拟化</title>
    <link href="http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <id>http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/</id>
    <published>2020-03-08T12:19:13.591Z</published>
    <updated>2020-01-13T11:22:49.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟化分类"><a href="#虚拟化分类" class="headerlink" title="虚拟化分类"></a>虚拟化分类</h1><p>虚拟化可分为半虚拟化和全虚拟化。半虚拟化和全虚拟化的本质区别在于虚拟化层。</p><h1 id="半虚拟化网络（Virtio驱动）"><a href="#半虚拟化网络（Virtio驱动）" class="headerlink" title="半虚拟化网络（Virtio驱动）"></a>半虚拟化网络（Virtio驱动）</h1><p>半虚拟化主机需要对客户机操作系统进行一定的修改才能使用。半虚拟化宿主机和虚拟机都需要安装Virtio的虚拟工具。</p><h2 id="半虚拟化安装过程"><a href="#半虚拟化安装过程" class="headerlink" title="半虚拟化安装过程"></a>半虚拟化安装过程</h2><p>目前主流操作系统都默认带有Virtio的网络驱动，只需要再内核中看看是否支持。</p><p>在启动虚拟机的时候加入参数virtio-net-oci，指定网卡if=virtio（网卡类型）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟化分类&quot;&gt;&lt;a href=&quot;#虚拟化分类&quot; class=&quot;headerlink&quot; title=&quot;虚拟化分类&quot;&gt;&lt;/a&gt;虚拟化分类&lt;/h1&gt;&lt;p&gt;虚拟化可分为半虚拟化和全虚拟化。半虚拟化和全虚拟化的本质区别在于虚拟化层。&lt;/p&gt;
&lt;h1 id=&quot;半虚拟化网络（V
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/KVM概念</title>
    <link href="http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/KVM%E6%A6%82%E5%BF%B5/"/>
    <id>http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/KVM%E6%A6%82%E5%BF%B5/</id>
    <published>2020-03-08T12:19:13.587Z</published>
    <updated>2020-01-13T11:22:49.347Z</updated>
    
    <content type="html"><![CDATA[<p>目前各大云计算厂商都在使用虚拟化云服务，大部分以VMware、Xen和KVM（Openstack）等架构，KVM是使用最广的虚拟化方案。</p><p>虚拟化是将空闲的硬件资源分配到虚拟计算机中，使服务器的性能能达到最好，发挥到极致。</p><p>KVM是内核加强虚拟机，从他的名称可以看出这是个基于内核的功能。</p><p>KVM是虚拟机软件，那么运行这个软件则要有CPU虚拟化选项打开，否则CPU无法进行虚拟化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前各大云计算厂商都在使用虚拟化云服务，大部分以VMware、Xen和KVM（Openstack）等架构，KVM是使用最广的虚拟化方案。&lt;/p&gt;
&lt;p&gt;虚拟化是将空闲的硬件资源分配到虚拟计算机中，使服务器的性能能达到最好，发挥到极致。&lt;/p&gt;
&lt;p&gt;KVM是内核加强虚拟机，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>虚拟化（KVM）/CPU虚拟及内存虚拟</title>
    <link href="http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/CPU%E8%99%9A%E6%8B%9F%E5%8F%8A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F/"/>
    <id>http://www.huckops.xyz/2020/03/08/%E8%99%9A%E6%8B%9F%E5%8C%96%EF%BC%88KVM%EF%BC%89/CPU%E8%99%9A%E6%8B%9F%E5%8F%8A%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F/</id>
    <published>2020-03-08T12:19:13.583Z</published>
    <updated>2020-01-13T11:22:49.313Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件虚拟化（CPU和内存）"><a href="#硬件虚拟化（CPU和内存）" class="headerlink" title="硬件虚拟化（CPU和内存）"></a>硬件虚拟化（CPU和内存）</h1><h2 id="常用CPU架构"><a href="#常用CPU架构" class="headerlink" title="常用CPU架构"></a>常用CPU架构</h2><h3 id="SMP技术"><a href="#SMP技术" class="headerlink" title="SMP技术"></a>SMP技术</h3><p>这种架构CPU共同访问所有内存，速率比较低，且效率也低。</p><h3 id="NUMA技术"><a href="#NUMA技术" class="headerlink" title="NUMA技术"></a>NUMA技术</h3><p>这是最常见的虚拟化技术，CPU直接通信自己所属的内存，直接调用，效率较高。</p><p><strong>这里需要用到numactl插件，需手动安装一下</strong></p><p>看以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bash$ numactl --hardware</span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1 2 3 4 5 6 7</span><br><span class="line">node 0 size: 7850 MB</span><br><span class="line">node 0 free: 4704 MB</span><br><span class="line">node distances:</span><br><span class="line">node   0 </span><br><span class="line">  0:  10</span><br></pre></td></tr></table></figure><p>从以上代码得，这台电脑是单CPU，是多核的CPU。内存一共7850M，空余4704M。</p><p>查看NUMA使用的内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bash# numasat -c qemu-kvm</span><br><span class="line">Per-node numastat info (in MBs):</span><br><span class="line">                Node 0 Total</span><br><span class="line">                ------ -----</span><br><span class="line">Numa_Hit         19365 19365</span><br><span class="line">Numa_Miss            0     0</span><br><span class="line">Numa_Foreign         0     0</span><br><span class="line">Interleave_Hit     175   175</span><br><span class="line">Local_Node       19365 19365</span><br><span class="line">Other_Node           0     0</span><br><span class="line">Local_Node       19365 19365</span><br><span class="line">Other_Node           0     0</span><br></pre></td></tr></table></figure><p>可以看到内存的占用状况。</p><h1 id="KSM技术："><a href="#KSM技术：" class="headerlink" title="KSM技术："></a>KSM技术：</h1><p>虚拟主句和宿主主机内存合并。</p><h2 id="内存气球技术"><a href="#内存气球技术" class="headerlink" title="内存气球技术"></a>内存气球技术</h2><p>需要virt balloon插件调节内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;硬件虚拟化（CPU和内存）&quot;&gt;&lt;a href=&quot;#硬件虚拟化（CPU和内存）&quot; class=&quot;headerlink&quot; title=&quot;硬件虚拟化（CPU和内存）&quot;&gt;&lt;/a&gt;硬件虚拟化（CPU和内存）&lt;/h1&gt;&lt;h2 id=&quot;常用CPU架构&quot;&gt;&lt;a href=&quot;#常用
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
